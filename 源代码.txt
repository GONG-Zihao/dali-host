项目源码汇总（用于软著提交）
生成时间: 2025-09-25 23:42:38 +0800
仓库根目录: /home/zihaogong/projects/dali-host
包含文件数: 53
排除目录: .git, .venv, .idea, .vscode, __pycache__, 数据/
排除文件名: README*, requirements*
排除常见二进制/资源后缀: ttf, otf, woff, png, jpg, jpeg, gif, bmp, ico, pdf, zip, tar, gz, 7z, rar, *.pyc 等
—— 以下按路径字典序排列 ——

===== FILE: .gitignore =====
__pycache__/
*.py[cod]
*.pyo
*.egg-info/
.venv/
.env
.pytest_cache/
.mypy_cache/
.ruff_cache/
.coverage*
pip-wheel-metadata/
*.log

build/
dist/
*.spec
.vscode/
.idea/
.DS_Store

===== END FILE: .gitignore =====

===== FILE: app/api/local.py =====
"""占位的本地 API 框架。后续可根据需要实现 REST/WebSocket 服务。"""

from __future__ import annotations


class LocalAPIServer:
    def __init__(self, host: str = "127.0.0.1", port: int = 5589):
        self.host = host
        self.port = port

    def start(self):  # pragma: no cover - 未实现
        raise NotImplementedError("Local API server 尚未实现")

    def stop(self):  # pragma: no cover - 未实现
        raise NotImplementedError("Local API server 尚未实现")


===== END FILE: app/api/local.py =====

===== FILE: app/core/analysis/stats.py =====
from __future__ import annotations
from dataclasses import dataclass, asdict
from typing import List, Dict, Any
from pathlib import Path
import csv, math, statistics

@dataclass
class RunStats:
    name: str
    count: int
    total_ms: float
    mean_ms: float
    std_ms: float
    min_ms: float
    p50_ms: float
    p95_ms: float
    p99_ms: float
    max_ms: float
    approx_ops_per_s: float  # 约等于 1000 / mean_ms

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

def load_durations_csv(path: Path) -> List[float]:
    """
    读取 PanelBenchmark 导出的 CSV（列：index,duration_ms）
    返回 duration_ms 列（float 毫秒）。
    """
    vals: List[float] = []
    with path.open("r", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            try:
                vals.append(float(row["duration_ms"]))
            except Exception:
                # 兼容无表头或不同列名的情况
                try:
                    vals.append(float(row.get("duration", row.get("ms", ""))))
                except Exception:
                    continue
    if not vals:
        # 尝试无表头简单两列：index,duration_ms
        f2 = path.read_text(encoding="utf-8").strip().splitlines()
        for line in f2:
            if "," in line:
                try:
                    _idx, ms = line.split(",", 1)
                    if _idx.isdigit():
                        vals.append(float(ms))
                except Exception:
                    pass
    if not vals:
        raise ValueError(f"未能从 CSV 解析到任何 duration_ms：{path}")
    return vals

def _percentile_ms(data: List[float], q: float) -> float:
    """
    百分位（q in [0,100]），线性插值：与 numpy.percentile(method='linear') 近似
    """
    if not data:
        return 0.0
    xs = sorted(data)
    n = len(xs)
    if n == 1:
        return float(xs[0])
    pos = (q / 100.0) * (n - 1)
    lo = int(math.floor(pos))
    hi = int(math.ceil(pos))
    if lo == hi:
        return float(xs[lo])
    frac = pos - lo
    return float(xs[lo] * (1 - frac) + xs[hi] * frac)

def compute_stats(name: str, durations_ms: List[float]) -> RunStats:
    if not durations_ms:
        raise ValueError("空数据")
    total_ms = float(sum(durations_ms))
    mean_ms = float(statistics.fmean(durations_ms))
    std_ms = float(statistics.pstdev(durations_ms)) if len(durations_ms) > 1 else 0.0
    return RunStats(
        name=name,
        count=len(durations_ms),
        total_ms=total_ms,
        mean_ms=mean_ms,
        std_ms=std_ms,
        min_ms=float(min(durations_ms)),
        p50_ms=_percentile_ms(durations_ms, 50),
        p95_ms=_percentile_ms(durations_ms, 95),
        p99_ms=_percentile_ms(durations_ms, 99),
        max_ms=float(max(durations_ms)),
        approx_ops_per_s=(1000.0 / mean_ms) if mean_ms > 0 else 0.0,
    )

def ecdf(values: List[float]):
    """经验分布函数：返回 (xs_sorted, ys[0..1])"""
    if not values:
        return [], []
    xs = sorted(values)
    n = len(xs)
    ys = [(i + 1) / n for i in range(n)]
    return xs, ys

===== END FILE: app/core/analysis/stats.py =====

===== FILE: app/core/bench/worker.py =====
from __future__ import annotations
import time, threading, statistics
from dataclasses import dataclass
from typing import Callable, Dict, Any, Optional, List

from PySide6.QtCore import QObject, Signal

@dataclass
class BenchPlan:
    # 地址
    mode: str                # 'broadcast' | 'short' | 'group'
    addr_val: Optional[int]  # None/0..63/0..15
    unaddr: bool             # 仅未寻址（仅广播有用）

    # 任务类型与参数
    task: str                # 'arc_fixed'|'arc_sweep'|'scene_recall'|'dt8_tc_fixed'|'dt8_xy_fixed'|'dt8_rgbw_fixed'
    params: Dict[str, Any]   # 各任务所需参数

    # 节奏
    total: int               # 发送总次数
    interval_ms: int         # 两次发送的目标间隔（毫秒）
    recv_timeout_ms: int     # 可选接收等待（目前大多数命令不强制）

class BenchWorker(QObject):
    progress = Signal(dict)   # {sent, ok, err, last_ms, avg_ms, min_ms, max_ms}
    finished = Signal(dict)   # {sent, ok, err, avg_ms, min_ms, max_ms, durations}
    log = Signal(str)

    def __init__(self, controller, plan: BenchPlan):
        super().__init__()
        self.ctrl = controller
        self.plan = plan
        self._stop = threading.Event()
        self._durations: List[float] = []
        self._ok = 0
        self._err = 0
        self._sent = 0

    def stop(self):
        self._stop.set()

    # --- 任务映射 ---
    def _send_once(self, i: int):
        p = self.plan
        t0 = time.perf_counter()

        try:
            if p.task == "arc_fixed":
                v = int(p.params.get("arc", 128))
                self.ctrl.send_arc(p.mode, v, p.addr_val, p.unaddr)

            elif p.task == "arc_sweep":
                lo = int(p.params.get("lo", 0))
                hi = int(p.params.get("hi", 254))
                step = max(1, int(p.params.get("step", 5)))
                # 循环扫描：i 决定当前值
                rng = hi - lo + 1
                v = lo + ((i * step) % rng)
                v = max(lo, min(hi, v))
                self.ctrl.send_arc(p.mode, v, p.addr_val, p.unaddr)

            elif p.task == "scene_recall":
                sc = int(p.params.get("scene", 0))
                self.ctrl.scene_recall(p.mode, sc, p.addr_val, p.unaddr)

            elif p.task == "dt8_tc_fixed":
                k = int(p.params.get("kelvin", 4000))
                self.ctrl.dt8_set_tc_kelvin(p.mode, k, p.addr_val, p.unaddr)

            elif p.task == "dt8_xy_fixed":
                x = float(p.params.get("x", 0.313))
                y = float(p.params.get("y", 0.329))
                self.ctrl.dt8_set_xy(p.mode, x, y, p.addr_val, p.unaddr)

            elif p.task == "dt8_rgbw_fixed":
                r = int(p.params.get("r", 0))
                g = int(p.params.get("g", 0))
                b = int(p.params.get("b", 0))
                w = int(p.params.get("w", 0))
                self.ctrl.dt8_set_rgbw(p.mode, r, g, b, w, p.addr_val, p.unaddr)

            else:
                raise ValueError(f"未知任务：{p.task}")

            ok = True
        except Exception as e:
            ok = False
            self.log.emit(f"ERR: {e!r}")

        t1 = time.perf_counter()
        dt_ms = (t1 - t0) * 1000.0
        self._sent += 1
        if ok:
            self._ok += 1
        else:
            self._err += 1

        self._durations.append(dt_ms)
        avg = statistics.fmean(self._durations) if self._durations else 0.0
        self.progress.emit({
            "sent": self._sent, "ok": self._ok, "err": self._err,
            "last_ms": dt_ms, "avg_ms": avg,
            "min_ms": min(self._durations) if self._durations else 0.0,
            "max_ms": max(self._durations) if self._durations else 0.0,
        })

    def run(self):
        p = self.plan
        interval = max(0.0, float(p.interval_ms) / 1000.0)
        for i in range(p.total):
            if self._stop.is_set():
                break
            start = time.perf_counter()
            self._send_once(i)
            # 节流到指定间隔
            used = time.perf_counter() - start
            remain = interval - used
            if remain > 0:
                time.sleep(remain)

        avg = statistics.fmean(self._durations) if self._durations else 0.0
        self.finished.emit({
            "sent": self._sent, "ok": self._ok, "err": self._err,
            "avg_ms": avg,
            "min_ms": min(self._durations) if self._durations else 0.0,
            "max_ms": max(self._durations) if self._durations else 0.0,
            "durations": self._durations,
        })

===== END FILE: app/core/bench/worker.py =====

===== FILE: app/core/config.py =====
from __future__ import annotations
from pathlib import Path
import logging

try:
    import yaml  # pip install pyyaml
except Exception:
    yaml = None

_DEFAULT = {
    "gateway": {
        "type": "mock",   # "tcp" | "serial" | "hid" | "mock"
        "host": "127.0.0.1",
        "port": 5588,
        "timeout_sec": 0.8,
    }
}

def load_yaml(path: Path) -> dict:
    log = logging.getLogger("Config")
    if path.exists() and yaml is not None:
        try:
            return yaml.safe_load(path.read_text(encoding="utf-8")) or {}
        except Exception as e:
            log.warning("YAML 解析失败，使用默认配置: %s", e)
    elif yaml is None:
        log.warning("未安装 pyyaml，使用默认配置")
    return {}

def get_app_config(root_dir: Path) -> dict:
    cfg_dir = root_dir / "配置"
    if not cfg_dir.exists():
        alt = root_dir / "config"
        if alt.exists():
            cfg_dir = alt
    app_cfg  = load_yaml(cfg_dir / "应用.yaml")
    conn_cfg = load_yaml(cfg_dir / "连接.yaml")
    dali_cfg = load_yaml(cfg_dir / "dali.yaml")

    cfg = {}
    cfg.update(app_cfg); cfg.update(conn_cfg); cfg.update(dali_cfg)

    # 默认
    for k, v in _DEFAULT.items():
        cfg.setdefault(k, v)
        if isinstance(v, dict):
            for kk, vv in v.items():
                cfg[k].setdefault(kk, vv)

    # ops 兜底
    ops = cfg.setdefault("ops", {})
    ops.setdefault("recall_scene_base", 64)
    ops.setdefault("store_dtr_as_scene_base", 80)
    ops.setdefault("remove_from_scene_base", 144)
    ops.setdefault("add_to_group_base", 96)
    ops.setdefault("remove_from_group_base", 112)
    ops.setdefault("write_dtr", 163)
    ops.setdefault("query_status", 144)
    ops.setdefault("query_groups_0_7", 192)
    ops.setdefault("query_groups_8_15", 193)
    ops.setdefault("query_scene_level_base", 176)
    # DT8 默认
    ops.setdefault("dt8_enable_addr", 193)
    ops.setdefault("dt8_set_tc_opcode", 231)
    ops.setdefault("write_dtr0_addr", 163)
    ops.setdefault("write_dtr1_addr", 195)

    # Tc 范围
    tc = cfg.setdefault("tc", {})
    tc.setdefault("kelvin_min", 1700)
    tc.setdefault("kelvin_max", 8000)
    # xy
    ops.setdefault("dt8_set_x_opcode", 224)
    ops.setdefault("dt8_set_y_opcode", 225)
    # primary 映射
    prim = ops.setdefault("dt8_set_primary", {})
    prim.setdefault("r", 226);
    prim.setdefault("g", 227)
    prim.setdefault("b", 228);
    prim.setdefault("w", 229)
    cfg.setdefault("presets", [
        {"name": "红", "mode": "rgbw", "values": {"r": 254, "g": 0, "b": 0, "w": 0}},
        {"name": "绿", "mode": "rgbw", "values": {"r": 0, "g": 254, "b": 0, "w": 0}},
        {"name": "蓝", "mode": "rgbw", "values": {"r": 0, "g": 0, "b": 254, "w": 0}},
        {"name": "暖白(2700K)", "mode": "tc", "kelvin": 2700},
        {"name": "中性白(4000K)", "mode": "tc", "kelvin": 4000},
        {"name": "冷白(6500K)", "mode": "tc", "kelvin": 6500},
        {"name": "D65", "mode": "xy", "values": {"x": 0.3127, "y": 0.3290}},
    ])
    return cfg


===== END FILE: app/core/config.py =====

===== FILE: app/core/controller.py =====
from __future__ import annotations
import logging
from pathlib import Path
from typing import Dict, List
from .transport.base import Transport, MockTransport
from .transport.tcp_gateway import TcpGateway
from .transport.serial_port import SerialGateway
from .transport.hid_gateway import HidGateway
from .dali.frames import addr_broadcast, addr_short, addr_group, make_forward_frame

class Controller:
    """上位机核心：把GUI动作翻译为传输层帧。"""
    def __init__(self, cfg: dict):
        self._cfg = cfg
        self._log = logging.getLogger("Controller")
        gw_cfg = cfg.get("gateway", {})
        gtype = gw_cfg.get("type", "mock").lower()
        if gtype == "tcp":
            self._transport: Transport = TcpGateway(
                host=gw_cfg.get("host", "127.0.0.1"),
                port=int(gw_cfg.get("port", 5588)),
                timeout=float(gw_cfg.get("timeout_sec", 0.8)),
            )
        elif gtype == "serial":
            self._transport = SerialGateway(
                port=gw_cfg.get("port", "COM1"),
                baudrate=int(gw_cfg.get("baudrate", 19200)),
                timeout=float(gw_cfg.get("timeout_sec", 0.8)),
            )
        elif gtype == "hid":
            vid = gw_cfg.get("vid")
            pid = gw_cfg.get("pid")
            self._transport = HidGateway(
                vendor_id=int(vid, 0) if isinstance(vid, str) else vid,
                product_id=int(pid, 0) if isinstance(pid, str) else pid,
                timeout=float(gw_cfg.get("timeout_sec", 0.8)),
            )
        else:
            self._transport = MockTransport()
        self._log.info("Transport: %s", self._transport.__class__.__name__)

    # 连接管理
    def connect(self) -> bool:
        try:
            self._transport.connect()
            return True
        except Exception as e:
            self._log.error("连接失败: %s", e, exc_info=True)
            return False

    def disconnect(self) -> None:
        try:
            self._transport.disconnect()
        except Exception:
            pass

    def is_connected(self) -> bool:
        return self._transport.is_connected()

    # 调光：发送 ARC 0..254（is_command=False）
    def send_arc(self, mode: str, value: int, addr_val: int | None = None, unaddr: bool = False) -> None:
        """mode: 'broadcast' | 'short' | 'group'"""
        value = max(0, min(254, int(value)))
        if mode == "broadcast":
            a = addr_broadcast(is_command=False, unaddressed=unaddr)
        elif mode == "short":
            if addr_val is None:
                raise ValueError("短地址缺失")
            a = addr_short(int(addr_val), is_command=False)
        elif mode == "group":
            if addr_val is None:
                raise ValueError("组地址缺失")
            a = addr_group(int(addr_val), is_command=False)
        else:
            raise ValueError("未知地址模式")

        frame = make_forward_frame(a, value)
        self._transport.send(frame)
    # 发送命令，并尝试读取一个响应包（通常是1字节）
    def send_command(self, mode: str, opcode: int,
                     addr_val: int | None = None, unaddr: bool = False,
                     timeout: float = 0.3) -> bytes | None:
        from .dali.frames import addr_broadcast, addr_short, addr_group, make_forward_frame
        opcode = int(opcode) & 0xFF

        if mode == "broadcast":
            a = addr_broadcast(is_command=True, unaddressed=unaddr)
        elif mode == "short":
            if addr_val is None: raise ValueError("短地址缺失")
            a = addr_short(int(addr_val), is_command=True)
        elif mode == "group":
            if addr_val is None: raise ValueError("组地址缺失")
            a = addr_group(int(addr_val), is_command=True)
        else:
            raise ValueError("未知地址模式")

        frame = make_forward_frame(a, opcode)
        self._transport.send(frame)
        return self._transport.recv(timeout=timeout)

    # ========== 设备查询 ==========
    def query_status(self, short_addr: int, timeout: float = 0.3) -> bytes | None:
        opcode = int(self._cfg_ops().get("query_status", 144))
        return self.send_command("short", opcode, addr_val=int(short_addr), timeout=timeout)

    def query_groups(self, short_addr: int, timeout: float = 0.3) -> Dict[int, int]:
        ops = self._cfg_ops()
        groups: Dict[int, int] = {i: 0 for i in range(16)}

        lo_opcode = int(ops.get("query_groups_0_7", 192))
        hi_opcode = int(ops.get("query_groups_8_15", 193))

        lo_resp = self.send_command("short", lo_opcode, addr_val=int(short_addr), timeout=timeout)
        hi_resp = self.send_command("short", hi_opcode, addr_val=int(short_addr), timeout=timeout)

        if lo_resp:
            mask = lo_resp[0]
            for bit in range(8):
                groups[bit] = 1 if (mask >> bit) & 1 else 0
        if hi_resp:
            mask = hi_resp[0]
            for bit in range(8):
                groups[8 + bit] = 1 if (mask >> bit) & 1 else 0
        return groups

    def query_scene_levels(self, short_addr: int, timeout: float = 0.3) -> Dict[int, int | None]:
        ops = self._cfg_ops()
        base = int(ops.get("query_scene_level_base", 176))
        levels: Dict[int, int | None] = {}
        for scene in range(16):
            opcode = (base + scene) & 0xFF
            resp = self.send_command("short", opcode, addr_val=int(short_addr), timeout=timeout)
            if resp and len(resp) > 0:
                levels[scene] = int(resp[0])
            else:
                levels[scene] = None
        return levels

    def scan_devices(self, short_range: range | List[int] = range(64), timeout: float = 0.3) -> List[int]:
        found: List[int] = []
        for short in short_range:
            try:
                resp = self.query_status(int(short), timeout=timeout)
                if resp is not None:
                    found.append(int(short))
            except Exception as exc:  # pragma: no cover - transport failures only logged
                self._log.debug("query_status failed for %s: %s", short, exc)
        return found

    # ========== 组管理 ==========
    def group_add(self, target_mode: str, group: int, addr_val: int | None = None, unaddr: bool = False):
        """
        将目标（短地址 / 广播）加入 group(0..15)。
        注：组成员关系写入设备，通常应对短地址或广播操作，不对“组地址”本身操作。
        """
        ops = self._cfg_ops()
        opcode = int(ops["add_to_group_base"] + int(group))
        self._send_command_to_target(target_mode, opcode, addr_val, unaddr)

    def group_remove(self, target_mode: str, group: int, addr_val: int | None = None, unaddr: bool = False):
        """从 group(0..15) 中移除目标。"""
        ops = self._cfg_ops()
        opcode = int(ops["remove_from_group_base"] + int(group))
        self._send_command_to_target(target_mode, opcode, addr_val, unaddr)

    # ========== 场景管理 ==========
    def scene_recall(self, target_mode: str, scene: int, addr_val: int | None = None, unaddr: bool = False):
        """回放场景 scene(0..15)。"""
        ops = self._cfg_ops()
        opcode = int(ops["recall_scene_base"] + int(scene))
        self._send_command_to_target(target_mode, opcode, addr_val, unaddr)

    def scene_store_level(self, target_mode: str, scene: int, level: int,
                          addr_val: int | None = None, unaddr: bool = False):
        """
        把 level(0..254) 写入为场景 scene(0..15) 的亮度：
        先写 DTR，再发送“将 DTR 保存为场景 scene”的命令。
        """
        ops = self._cfg_ops()
        write_dtr = int(ops["write_dtr"])
        store_base = int(ops["store_dtr_as_scene_base"])
        scene = int(scene) & 0x0F
        level = max(0, min(254, int(level)))

        # Step1: 写DTR（命令发给目标）
        self._send_command_to_target(target_mode, write_dtr, addr_val, unaddr)
        # Step2: 再发一次写DTR值？——有的网关把“写DTR值”实现为“先ARC=level，再WRITE_DTR”
        # 为了兼容性，先把ARC调到目标值（不影响最终存档），再写入DTR命令一次：
        from .dali.frames import make_forward_frame, addr_broadcast, addr_short, addr_group
        # 设ARC（S=0）
        a = self._address_byte(target_mode, addr_val, unaddr, is_command=False)
        self._transport.send(make_forward_frame(a, level))
        # 写DTR（S=1）
        a_cmd = self._address_byte(target_mode, addr_val, unaddr, is_command=True)
        self._transport.send(make_forward_frame(a_cmd, write_dtr))

        # Step3: 将DTR保存为场景
        self._send_command_to_target(target_mode, store_base + scene, addr_val, unaddr)

    def scene_remove(self, target_mode: str, scene: int, addr_val: int | None = None, unaddr: bool = False):
        """将目标从场景 scene(0..15) 中移除。"""
        ops = self._cfg_ops()
        opcode = int(ops["remove_from_scene_base"] + int(scene))
        self._send_command_to_target(target_mode, opcode, addr_val, unaddr)

    # ========== 工具函数 ==========
    def _cfg_ops(self) -> dict:
        # 从 MainWindow 传入的 config 获取 ops；若没挂入，回退默认
        try:
            return getattr(self, "_ops_cache")
        except AttributeError:
            pass
        ops = getattr(self, "_cfg", {}).get("ops", {}) if hasattr(self, "_cfg") else {}
        if not ops:
            ops = {
                "recall_scene_base": 64, "store_dtr_as_scene_base": 80, "remove_from_scene_base": 144,
                "add_to_group_base": 96, "remove_from_group_base": 112, "write_dtr": 163
            }
        self._ops_cache = ops
        return ops

    def _address_byte(self, mode: str, addr_val: int | None, unaddr: bool, is_command: bool) -> int:
        from .dali.frames import addr_broadcast, addr_short, addr_group
        if mode == "broadcast":
            return addr_broadcast(is_command=is_command, unaddressed=unaddr)
        elif mode == "short":
            if addr_val is None: raise ValueError("短地址缺失")
            return addr_short(int(addr_val), is_command=is_command)
        elif mode == "group":
            if addr_val is None: raise ValueError("组地址缺失")
            return addr_group(int(addr_val), is_command=is_command)
        else:
            raise ValueError("未知目标模式")

    def _send_command_to_target(self, mode: str, opcode: int, addr_val: int | None, unaddr: bool):
        from .dali.frames import make_forward_frame
        a = self._address_byte(mode, addr_val, unaddr, is_command=True)
        frame = make_forward_frame(a, int(opcode) & 0xFF)
        self._transport.send(frame)

    # ====== DT8 / Tc ======
    def dt8_set_tc_kelvin(self, mode: str, kelvin: int,
                          addr_val: int | None = None, unaddr: bool = False):
        """以 K 设置色温（DT8 / Tc）。内部自动换算 Mirek 并写 DTR0/1，再启用DT8后发送 Set-Tc。"""
        ops = self._cfg.get("ops", {})
        tc_cfg = self._cfg.get("tc", {})
        kmin = int(tc_cfg.get("kelvin_min", 1700))
        kmax = int(tc_cfg.get("kelvin_max", 8000))

        k = max(kmin, min(kmax, int(kelvin)))
        # Mirek = 1e6 / K ；范围 1..65534（0保留），四舍五入
        mirek = max(1, min(65534, int(round(1_000_000 / float(k)))))
        lsb = mirek & 0xFF
        msb = (mirek >> 8) & 0xFF

        from .dali.frames import make_forward_frame

        # 写 DTR0 / DTR1 （特殊地址字节）
        self._transport.send(make_forward_frame(int(ops["write_dtr0_addr"]) & 0xFF, lsb))
        self._transport.send(make_forward_frame(int(ops["write_dtr1_addr"]) & 0xFF, msb))

        # 启用 Device Type = 8（特殊地址字节 0xC1, data=8）
        self._transport.send(make_forward_frame(int(ops["dt8_enable_addr"]) & 0xFF, 8))

        # 发送“Set Temporary Colour Temperature Tc”（寻址命令）
        a = self._address_byte(mode, addr_val, unaddr, is_command=True)
        self._transport.send(make_forward_frame(a, int(ops["dt8_set_tc_opcode"]) & 0xFF))

        return {"kelvin": k, "mirek": mirek}

    # 可选：直接以 Mirek 设置（给自动化/脚本用）
    def dt8_set_tc_mirek(self, mode: str, mirek: int,
                         addr_val: int | None = None, unaddr: bool = False):
        mirek = max(1, min(65534, int(mirek)))
        lsb = mirek & 0xFF
        msb = (mirek >> 8) & 0xFF
        ops = self._cfg.get("ops", {})
        from .dali.frames import make_forward_frame
        self._transport.send(make_forward_frame(int(ops["write_dtr0_addr"]) & 0xFF, lsb))
        self._transport.send(make_forward_frame(int(ops["write_dtr1_addr"]) & 0xFF, msb))
        self._transport.send(make_forward_frame(int(ops["dt8_enable_addr"]) & 0xFF, 8))
        a = self._address_byte(mode, addr_val, unaddr, is_command=True)
        self._transport.send(make_forward_frame(a, int(ops["dt8_set_tc_opcode"]) & 0xFF))
        return {"mirek": mirek, "kelvin": int(round(1_000_000 / mirek))}

    # ====== DT8 / xy ======
    def dt8_set_xy(self, mode: str, x: float, y: float,
                   addr_val: int | None = None, unaddr: bool = False):
        """
        设置 CIE xy（0..1）。内部：xy*65535 → 16位；依次写 X、写 Y。
        每次：写 DTR0/1 -> Enable DT8 -> 发送对应 opcode（寻址）。
        """
        ops = self._cfg.get("ops", {})
        set_x = int(ops.get("dt8_set_x_opcode", 224))
        set_y = int(ops.get("dt8_set_y_opcode", 225))
        w_dtr0 = int(ops.get("write_dtr0_addr", 163))  # 0xA3
        w_dtr1 = int(ops.get("write_dtr1_addr", 195))  # 0xC3
        ena    = int(ops.get("dt8_enable_addr", 193))  # 0xC1

        def _u16(v: float) -> tuple[int, int]:
            n = max(0, min(65535, int(round(float(v) * 65535.0))))
            return n & 0xFF, (n >> 8) & 0xFF

        from .dali.frames import make_forward_frame
        # X
        lsb, msb = _u16(x)
        self._transport.send(make_forward_frame(w_dtr0, lsb))
        self._transport.send(make_forward_frame(w_dtr1, msb))
        self._transport.send(make_forward_frame(ena, 8))
        a = self._address_byte(mode, addr_val, unaddr, is_command=True)
        self._transport.send(make_forward_frame(a, set_x & 0xFF))

        # Y
        lsb, msb = _u16(y)
        self._transport.send(make_forward_frame(w_dtr0, lsb))
        self._transport.send(make_forward_frame(w_dtr1, msb))
        self._transport.send(make_forward_frame(ena, 8))
        self._transport.send(make_forward_frame(a, set_y & 0xFF))

        return {
            "x_u16": int(round(x*65535)), "y_u16": int(round(y*65535)),
            "x": float(x), "y": float(y)
        }

    # ====== DT8 / RGBW(A/F) 单通道 ======
    def dt8_set_primary(self, mode: str, channel: str, level: int,
                        addr_val: int | None = None, unaddr: bool = False):
        """
        设置单个主色通道（RGBW/可扩展 A,F）。
        level 0..254（常见做法：写入 DTR0 然后发 'Set Primary X'）
        """
        ops = self._cfg.get("ops", {})
        prim_map: dict = ops.get("dt8_set_primary", {})
        opcode = prim_map.get(channel.lower())
        if opcode is None:
            raise ValueError(f"配置中未定义主色通道 '{channel}' 的 opcode")
        w_dtr0 = int(ops.get("write_dtr0_addr", 163))
        ena    = int(ops.get("dt8_enable_addr", 193))

        level = max(0, min(254, int(level)))
        from .dali.frames import make_forward_frame

        self._transport.send(make_forward_frame(w_dtr0, level & 0xFF))
        self._transport.send(make_forward_frame(ena, 8))
        a = self._address_byte(mode, addr_val, unaddr, is_command=True)
        self._transport.send(make_forward_frame(a, int(opcode) & 0xFF))
        return {"channel": channel.lower(), "level": level}

    # ====== DT8 / RGBW 批量 ======
    def dt8_set_rgbw(self, mode: str, r: int, g: int, b: int, w: int = 0,
                     addr_val: int | None = None, unaddr: bool = False):
        out = []
        for ch, val in (("r", r), ("g", g), ("b", b), ("w", w)):
            out.append(self.dt8_set_primary(mode, ch, val, addr_val=addr_val, unaddr=unaddr))
        return out

    # 原始两字节前向帧（addr, data）
    def send_raw(self, addr_byte: int, data_byte: int):
        from .dali.frames import make_forward_frame
        a = int(addr_byte) & 0xFF
        d = int(data_byte) & 0xFF
        self._transport.send(make_forward_frame(a, d))

    # 批量发送多帧
    def send_sequence(self, frames: list[tuple[int, int]]):
        for a, d in frames:
            self.send_raw(a, d)

===== END FILE: app/core/controller.py =====

===== FILE: app/core/dali/frames.py =====
from __future__ import annotations

def addr_short(short_addr: int, is_command: bool) -> int:
    """0AAA AAAS：短地址 0..63；S=0 表示ARC亮度，S=1表示命令。"""
    if not (0 <= short_addr < 64):
        raise ValueError("short_addr must be 0..63")
    s = 1 if is_command else 0
    return ((short_addr & 0x3F) << 1) | s

def addr_group(group: int, is_command: bool) -> int:
    """100A AAAS：组地址 0..15。"""
    if not (0 <= group < 16):
        raise ValueError("group must be 0..15")
    s = 1 if is_command else 0
    return 0b1000_0000 | ((group & 0x0F) << 1) | s

def addr_broadcast(is_command: bool, unaddressed: bool = False) -> int:
    """
    广播：1111111S -> 0xFE/0xFF
    未寻址广播：1111110S -> 0xFC/0xFD
    """
    base7 = 0x7E if unaddressed else 0x7F  # 7位高位
    s = 1 if is_command else 0
    return (base7 << 1) | s


def make_forward_frame(addr_byte: int, opcode_or_arc: int) -> bytes:
    """前向帧：地址字节 + 操作码/亮度（8位）。"""
    return bytes([(addr_byte & 0xFF), (opcode_or_arc & 0xFF)])

===== END FILE: app/core/dali/frames.py =====

===== FILE: app/core/events.py =====
from __future__ import annotations
from PySide6.QtCore import QObject, Signal

class EventBus(QObject):
    connection_changed = Signal(bool)  # True=已连接，False=未连接

bus = EventBus()

===== END FILE: app/core/events.py =====

===== FILE: app/core/io/apply.py =====
from __future__ import annotations
from typing import List, Dict, Any
from pathlib import Path

from .state_io import GroupEntry, SceneEntry

def apply_groups(controller, entries: List[GroupEntry], clear_others: bool = False):
    """
    将组成员关系应用到设备。
    - 若 clear_others=True，会对每个 short 发送“从所有未列出的组移除”，总最多16条。
    - 否则只发送“加入列表中的组”（不做移除）。
    """
    for e in entries:
        want = set(int(g) for g in e.groups)
        if clear_others:
            for g in range(16):
                if g in want:
                    controller.group_add("short", g, addr_val=int(e.short))
                else:
                    controller.group_remove("short", g, addr_val=int(e.short))
        else:
            for g in sorted(want):
                controller.group_add("short", g, addr_val=int(e.short))

def apply_scenes(controller, entries: List[SceneEntry], recall_after_store: bool = False):
    """
    将亮度表写入场景。entries[i].levels 形如 {"2":128, "5":254}
    """
    for e in entries:
        for s_str, level in e.levels.items():
            scene = int(s_str)
            controller.scene_store_level("short", scene, int(level), addr_val=int(e.short))
            if recall_after_store:
                controller.scene_recall("short", scene, addr_val=int(e.short))

def merge_presets(cfg_presets: List[Dict[str, Any]], user_presets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """按 name 去重合并（user 覆盖同名项）"""
    out = {p.get("name", f"preset-{i}"): p for i, p in enumerate(cfg_presets or [])}
    for p in (user_presets or []):
        name = p.get("name")
        if not name:
            name = f"user-{len(out)}"
            p = dict(p); p["name"] = name
        out[name] = p
    return list(out.values())

===== END FILE: app/core/io/apply.py =====

===== FILE: app/core/io/state_io.py =====
from __future__ import annotations
from dataclasses import dataclass, asdict
from typing import List, Dict, Any
from pathlib import Path
import json

SCHEMA_VERSION = 1

@dataclass
class GroupEntry:
    short: int                # 0..63
    groups: List[int]         # 成员组 0..15

@dataclass
class SceneEntry:
    short: int                # 0..63
    levels: Dict[str, int]    # {"0":0..254, "1":..}

@dataclass
class StateFile:
    version: int
    groups: List[GroupEntry]
    scenes: List[SceneEntry]
    dt8_presets: List[Dict[str, Any]]  # 直接沿用我们面板使用的预设结构

def _ensure_range(v: int, lo: int, hi: int, name="value"):
    if not (lo <= v <= hi):
        raise ValueError(f"{name} 超出范围 [{lo},{hi}]: {v}")

def load_state(path: Path) -> StateFile:
    data = json.load(open(path, "r", encoding="utf-8"))
    if not isinstance(data, dict): raise ValueError("顶层必须是对象")
    ver = int(data.get("version", SCHEMA_VERSION))

    # groups
    groups: List[GroupEntry] = []
    for it in (data.get("groups") or []):
        short = int(it["short"]); _ensure_range(short, 0, 63, "short")
        gl = [int(x) for x in it.get("groups", [])]
        for g in gl: _ensure_range(g, 0, 15, "group")
        groups.append(GroupEntry(short=short, groups=gl))

    # scenes
    scenes: List[SceneEntry] = []
    for it in (data.get("scenes") or []):
        short = int(it["short"]); _ensure_range(short, 0, 63, "short")
        lv = {str(k): int(v) for k, v in (it.get("levels") or {}).items()}
        for s, val in lv.items():
            _ensure_range(int(s), 0, 15, "scene")
            _ensure_range(val, 0, 254, "level")
        scenes.append(SceneEntry(short=short, levels=lv))

    presets = list(data.get("dt8_presets") or [])
    # 预设结构保持原样（name/mode/...）

    return StateFile(version=ver, groups=groups, scenes=scenes, dt8_presets=presets)

def save_state(path: Path, state: StateFile) -> None:
    out = {
        "version": state.version,
        "groups": [asdict(x) for x in state.groups],
        "scenes": [asdict(x) for x in state.scenes],
        "dt8_presets": state.dt8_presets,
    }
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(out, f, ensure_ascii=False, indent=2)

def empty_template() -> StateFile:
    return StateFile(version=SCHEMA_VERSION, groups=[], scenes=[], dt8_presets=[])

===== END FILE: app/core/io/state_io.py =====

===== FILE: app/core/logging/logger.py =====
from __future__ import annotations
import logging
import logging.config
from pathlib import Path

def setup_logging(app_name: str, log_dir: Path, level: str = "INFO") -> logging.Logger:
    log_dir.mkdir(parents=True, exist_ok=True)
    cfg = {
        "version": 1,
        "formatters": {
            "std": {"format": "%(asctime)s %(levelname)s [%(name)s] %(message)s"}
        },
        "handlers": {
            "console": {
                "class": "logging.StreamHandler",
                "formatter": "std",
                "level": level,
            },
            "file": {
                "class": "logging.handlers.RotatingFileHandler",
                "formatter": "std",
                "level": level,
                "filename": str(log_dir / f"{app_name}.log"),
                "maxBytes": 5 * 1024 * 1024,
                "backupCount": 3,
                "encoding": "utf-8",
            },
        },
        "root": {"handlers": ["console", "file"], "level": level},
    }
    logging.config.dictConfig(cfg)
    logger = logging.getLogger(app_name)
    logger.info("Logging initialized.")
    return logger

===== END FILE: app/core/logging/logger.py =====

===== FILE: app/core/presets.py =====
from __future__ import annotations
from pathlib import Path
import json
from typing import List, Dict, Any
from .io.apply import merge_presets

def load_user_presets(path: Path) -> list[dict]:
    if path.exists():
        try:
            data = json.load(open(path, "r", encoding="utf-8"))
            if isinstance(data, list):
                return data
        except Exception:
            return []
    return []

def save_user_presets(path: Path, presets: List[Dict[str, Any]]):
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(presets, f, ensure_ascii=False, indent=2)

def combined_presets(root_dir: Path, cfg: dict) -> list[dict]:
    cfg_presets = cfg.get("presets", [])
    user_path = root_dir / "数据" / "presets.json"
    user_presets = load_user_presets(user_path)
    return merge_presets(cfg_presets, user_presets)

===== END FILE: app/core/presets.py =====

===== FILE: app/core/schedule/manager.py =====
from __future__ import annotations
import json, uuid, math
from dataclasses import dataclass, asdict, field
from pathlib import Path
from typing import Optional, Dict, Any, Callable
from datetime import datetime, timedelta

from PySide6.QtCore import QObject, Signal, QTimer, QDateTime

# ---- 数据结构 ----
@dataclass
class Task:
    id: str
    name: str
    enabled: bool
    # 目标寻址
    mode: str                    # 'broadcast'|'short'|'group'
    addr_val: Optional[int]      # None/0..63/0..15
    unaddr: bool                 # 仅未寻址（仅广播有用）
    # 动作
    action: str                  # 'arc'|'scene'|'dt8_tc'|'dt8_xy'|'dt8_rgbw'|'raw'
    params: Dict[str, Any] = field(default_factory=dict)
    # 调度
    schedule: Dict[str, Any] = field(default_factory=dict)  # {type: 'once'|'interval'|'daily'|'weekly', ...}
    # 运行时记录
    last_run: Optional[str] = None   # ISO
    next_run: Optional[str] = None   # ISO
    run_count: int = 0

def now_dt() -> datetime:
    return datetime.now()

def iso(dt: Optional[datetime]) -> Optional[str]:
    return dt.isoformat(timespec="seconds") if dt else None

def parse_iso(s: Optional[str]) -> Optional[datetime]:
    if not s: return None
    try:
        return datetime.fromisoformat(s)
    except Exception:
        return None

# ---- Manager ----
class ScheduleManager(QObject):
    task_updated = Signal(str)    # task_id
    tasks_reloaded = Signal()
    message = Signal(str)

    def __init__(self, controller, store_dir: Path, parent=None):
        super().__init__(parent)
        self.ctrl = controller
        self.store_dir = store_dir
        self.store_dir.mkdir(parents=True, exist_ok=True)
        self.store_path = self.store_dir / "tasks.json"
        self._tasks: Dict[str, Task] = {}
        self._timers: Dict[str, QTimer] = {}
        self.load()

    # ---------- 持久化 ----------
    def load(self):
        if self.store_path.exists():
            try:
                data = json.load(open(self.store_path, "r", encoding="utf-8")) or []
                self._tasks.clear()
                for t in data:
                    task = Task(**t)
                    self._tasks[task.id] = task
                self.tasks_reloaded.emit()
            except Exception as e:
                self.message.emit(f"加载任务失败：{e}")
        self._rearm_all()

    def save(self):
        data = [asdict(t) for t in self._tasks.values()]
        self.store_path.parent.mkdir(parents=True, exist_ok=True)
        with open(self.store_path, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)

    # ---------- CRUD ----------
    def create(self, name: str, mode: str, addr_val: Optional[int], unaddr: bool,
               action: str, params: Dict[str, Any], schedule: Dict[str, Any], enabled: bool=True) -> str:
        tid = uuid.uuid4().hex
        task = Task(
            id=tid, name=name, enabled=enabled,
            mode=mode, addr_val=addr_val, unaddr=unaddr,
            action=action, params=params, schedule=schedule
        )
        self._tasks[tid] = task
        self._rearm_task(task)
        self.save()
        self.task_updated.emit(tid)
        return tid

    def update(self, tid: str, **fields):
        t = self._tasks.get(tid)
        if not t: return
        # 更新字段
        for k, v in fields.items():
            if hasattr(t, k): setattr(t, k, v)
        # 重新布防
        self._rearm_task(t)
        self.save()
        self.task_updated.emit(tid)

    def delete(self, tid: str):
        t = self._tasks.pop(tid, None)
        self._drop_timer(tid)
        self.save()
        if t: self.task_updated.emit(tid)

    def list(self) -> list[Task]:
        return list(self._tasks.values())

    # ---------- 执行 ----------
    def run_now(self, tid: str):
        t = self._tasks.get(tid)
        if not t: return
        self._execute_task(t)
        # 对于一次性任务，立即禁用
        if (t.schedule or {}).get("type") == "once":
            t.enabled = False
        self._rearm_task(t)
        self.save()
        self.task_updated.emit(tid)

    # ---------- 计时器 ----------
    def _drop_timer(self, tid: str):
        timer = self._timers.pop(tid, None)
        if timer:
            timer.stop()
            timer.deleteLater()

    def _rearm_all(self):
        for t in self._tasks.values():
            self._rearm_task(t)

    def _rearm_task(self, task: Task):
        # 先移除旧timer
        self._drop_timer(task.id)
        # 计算下一次运行
        next_dt = self._compute_next(task)
        task.next_run = iso(next_dt)
        if not task.enabled or not next_dt:
            return
        # 设置单次触发timer，到时执行完再决定下一次
        timer = QTimer(self)
        ms = max(0, int((next_dt - now_dt()).total_seconds() * 1000))
        timer.setSingleShot(True)
        def _fire():
            self._execute_task(task)
            # 更新记录
            task.last_run = iso(now_dt())
            task.run_count += 1
            # 重新计算下一次
            next2 = self._compute_next(task, after=now_dt())
            task.next_run = iso(next2)
            self.save()
            self.task_updated.emit(task.id)
            if task.enabled and next2:
                self._rearm_task(task)  # 继续排下一次
        timer.timeout.connect(_fire)
        timer.start(ms)
        self._timers[task.id] = timer

    # ---------- 调度规则 ----------
    def _compute_next(self, task: Task, after: Optional[datetime] = None) -> Optional[datetime]:
        if not task.enabled: return None
        rule = task.schedule or {}
        typ = (rule.get("type") or "").lower()
        base = after or now_dt()

        if typ == "once":
            dt = parse_iso(rule.get("datetime"))
            if not dt: return None
            if task.last_run:   # 执行过就不再触发
                return None
            return dt if dt > base else None

        if typ == "interval":
            every_ms = int(rule.get("every_ms", 1000))
            if task.last_run:
                last = parse_iso(task.last_run) or base
                next_dt = last + timedelta(milliseconds=every_ms)
            else:
                next_dt = base + timedelta(milliseconds=every_ms)
            return next_dt

        if typ == "daily":
            hh = int(rule.get("hour", 9)); mm = int(rule.get("minute", 0))
            candidate = base.replace(hour=hh, minute=mm, second=0, microsecond=0)
            if candidate <= base:
                candidate += timedelta(days=1)
            return candidate

        if typ == "weekly":
            # weekdays: [0..6] (Mon=0) + time
            hh = int(rule.get("hour", 9)); mm = int(rule.get("minute", 0))
            days = [int(d) for d in (rule.get("weekdays") or []) if 0 <= int(d) <= 6]
            if not days: return None
            # 找到 >= base 的最近一个
            base_day = base.weekday()
            for delta in range(0, 14):  # 两周窗口内必定命中
                d = (base_day + delta) % 7
                if d in days:
                    candidate = (base + timedelta(days=delta)).replace(hour=hh, minute=mm, second=0, microsecond=0)
                    if candidate > base:
                        return candidate
            return None

        return None

    # ---------- 具体动作 ----------
    def _execute_task(self, task: Task):
        try:
            if not self.ctrl.is_connected():
                self.message.emit(f"任务跳过（未连接）：{task.name}")
                return
            m = task.mode; a = task.addr_val; u = task.unaddr
            act = (task.action or "").lower()
            p = task.params or {}
            if act == "arc":
                v = int(p.get("value", 128))
                self.ctrl.send_arc(m, v, addr_val=a, unaddr=u)
            elif act == "scene":
                sc = int(p.get("scene", 0))
                self.ctrl.scene_recall(m, sc, addr_val=a, unaddr=u)
            elif act == "dt8_tc":
                k = int(p.get("kelvin", 4000))
                self.ctrl.dt8_set_tc_kelvin(m, k, addr_val=a, unaddr=u)
            elif act == "dt8_xy":
                x = float(p.get("x", 0.313)); y = float(p.get("y", 0.329))
                self.ctrl.dt8_set_xy(m, x, y, addr_val=a, unaddr=u)
            elif act == "dt8_rgbw":
                r = int(p.get("r", 0)); g = int(p.get("g", 0)); b = int(p.get("b", 0)); w = int(p.get("w", 0))
                self.ctrl.dt8_set_rgbw(m, r, g, b, w, addr_val=a, unaddr=u)
            elif act == "raw":
                # frames: [[addr,data], ...]
                frames = p.get("frames") or []
                for pair in frames:
                    if isinstance(pair, (list, tuple)) and len(pair) == 2:
                        self.ctrl.send_raw(int(pair[0]), int(pair[1]))
            else:
                self.message.emit(f"未知动作：{act}")
                return
            self.message.emit(f"任务执行：{task.name}")
        except Exception as e:
            self.message.emit(f"任务执行失败：{task.name} -> {e!r}")

===== END FILE: app/core/schedule/manager.py =====

===== FILE: app/core/transport/base.py =====
from __future__ import annotations
from abc import ABC, abstractmethod
import time
import logging

class Transport(ABC):
    """传输抽象层：屏蔽 TCP/串口/HID 差异。"""

    @abstractmethod
    def connect(self) -> None: ...
    @abstractmethod
    def disconnect(self) -> None: ...
    @abstractmethod
    def send(self, frame: bytes) -> None: ...
    @abstractmethod
    def recv(self, timeout: float = 0.5) -> bytes | None: ...
    @abstractmethod
    def is_connected(self) -> bool: ...

class MockTransport(Transport):
    """用于GUI联调与自动化测试的假设备。"""
    def __init__(self):
        self._connected = False
        self._log = logging.getLogger("MockTransport")
        self._last_sent: bytes | None = None

    def connect(self) -> None:
        self._connected = True
        self._log.info("Mock connected")

    def disconnect(self) -> None:
        self._connected = False
        self._log.info("Mock disconnected")

    def send(self, frame: bytes) -> None:
        self._last_sent = bytes(frame)
        self._log.info("SEND %s", frame.hex(" "))

    def recv(self, timeout: float = 0.5) -> bytes | None:
        import time
        time.sleep(min(timeout, 0.05))
        # 简单可重复的模拟：回一个1字节校验 (addr ^ data)
        if self._last_sent:
            b = (self._last_sent[0] ^ self._last_sent[1]) & 0xFF
            return bytes([b])
        return None

    def is_connected(self) -> bool:
        return self._connected

===== END FILE: app/core/transport/base.py =====

===== FILE: app/core/transport/hid_gateway.py =====
from __future__ import annotations

from .base import Transport


class HidGateway(Transport):
    """占位 HID Transport，实现留待未来拓展。"""

    def __init__(self, vendor_id: int | None = None, product_id: int | None = None, timeout: float = 0.8):
        self.vendor_id = vendor_id
        self.product_id = product_id
        self.timeout = timeout

    def connect(self) -> None:  # pragma: no cover - 未实现
        raise NotImplementedError("HidGateway 仍未实现")

    def disconnect(self) -> None:  # pragma: no cover - 未实现
        raise NotImplementedError("HidGateway 仍未实现")

    def send(self, frame: bytes) -> None:  # pragma: no cover - 未实现
        raise NotImplementedError("HidGateway 仍未实现")

    def recv(self, timeout: float = 0.5) -> bytes | None:  # pragma: no cover - 未实现
        raise NotImplementedError("HidGateway 仍未实现")

    def is_connected(self) -> bool:
        return False


===== END FILE: app/core/transport/hid_gateway.py =====

===== FILE: app/core/transport/serial_port.py =====
from __future__ import annotations

from .base import Transport


class SerialGateway(Transport):
    """占位 Serial Transport，实现留待未来拓展。"""

    def __init__(self, port: str, baudrate: int = 19200, timeout: float = 0.8):
        self.port = port
        self.baudrate = baudrate
        self.timeout = timeout

    def connect(self) -> None:  # pragma: no cover - 未实现
        raise NotImplementedError("SerialGateway 仍未实现")

    def disconnect(self) -> None:  # pragma: no cover - 未实现
        raise NotImplementedError("SerialGateway 仍未实现")

    def send(self, frame: bytes) -> None:  # pragma: no cover - 未实现
        raise NotImplementedError("SerialGateway 仍未实现")

    def recv(self, timeout: float = 0.5) -> bytes | None:  # pragma: no cover - 未实现
        raise NotImplementedError("SerialGateway 仍未实现")

    def is_connected(self) -> bool:
        return False


===== END FILE: app/core/transport/serial_port.py =====

===== FILE: app/core/transport/tcp_gateway.py =====
from __future__ import annotations
import socket
import logging
from .base import Transport

class TcpGateway(Transport):
    """简化版 TCP 透传：把2字节DALI前向帧直接写到网关。
    实际网关若有自定义封包，可在此改装（例如加前缀/校验/长度）。
    """
    def __init__(self, host: str, port: int, timeout: float = 0.8):
        self.host = host
        self.port = port
        self.timeout = timeout
        self._sock: socket.socket | None = None
        self._log = logging.getLogger("TcpGateway")

    def connect(self) -> None:
        if self._sock:
            return
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(self.timeout)
        s.connect((self.host, self.port))
        self._sock = s
        self._log.info("TCP connected %s:%s", self.host, self.port)

    def disconnect(self) -> None:
        if self._sock:
            try:
                self._sock.close()
            finally:
                self._sock = None
                self._log.info("TCP disconnected")

    def send(self, frame: bytes) -> None:
        if not self._sock:
            raise RuntimeError("Not connected")
        # 大多数网关支持短包直发；若需要可在此加协议头
        self._log.info("SEND %s", frame.hex(" "))
        try:
            self._sock.sendall(frame)
        except (BrokenPipeError, ConnectionResetError, OSError) as exc:
            self._log.warning("TCP send failed, closing socket: %s", exc)
            self.disconnect()
            raise RuntimeError("TCP connection lost") from exc

    def recv(self, timeout: float = 0.5) -> bytes | None:
        if not self._sock:
            return None
        self._sock.settimeout(timeout)
        try:
            data = self._sock.recv(1024)
            if data:
                self._log.info("RECV %s", data.hex(" "))
            return data or None
        except socket.timeout:
            return None

    def is_connected(self) -> bool:
        return self._sock is not None

===== END FILE: app/core/transport/tcp_gateway.py =====

===== FILE: app/core/utils/hexutil.py =====
from __future__ import annotations

def _to_byte(tok: str) -> int:
    tok = tok.strip().lower().replace("0x", "")
    if not tok or len(tok) > 2:
        raise ValueError(f"非法字节: {tok!r}")
    v = int(tok, 16)
    if not (0 <= v <= 255):
        raise ValueError(f"字节越界: {tok!r}")
    return v

def parse_pairs(text: str) -> list[tuple[int,int]]:
    """
    解析字符串为若干个(AA,BB)帧对。
    接受格式示例：
      FF 21
      ff 21; c1 08
      FF,21 | C1,08
    分隔符允许：空格、逗号、分号、竖线、换行
    """
    import re
    # 按分号或换行切分为多帧
    chunks = re.split(r"[;\n]+", text)
    out = []
    for ch in chunks:
        toks = [t for t in re.split(r"[\s,\|]+", ch.strip()) if t]
        if not toks:
            continue
        if len(toks) != 2:
            raise ValueError(f"每帧必须两字节，得到 {toks!r}")
        out.append((_to_byte(toks[0]), _to_byte(toks[1])))
    if not out:
        raise ValueError("未解析到任何帧")
    return out

def fmt_pair(a: int, d: int) -> str:
    return f"{a:02X} {d:02X}"

===== END FILE: app/core/utils/hexutil.py =====

===== FILE: app/experimental/__init__.py =====
"""Experimental panels retained for reference only."""


===== END FILE: app/experimental/__init__.py =====

===== FILE: app/experimental/panel_addr_alloc.py =====
# app/experimental/panel_addr_alloc.py
from __future__ import annotations

from PySide6 import QtWidgets, QtCore


class AddressAllocPanel(QtWidgets.QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setObjectName("PanelAddrAlloc")
        self.setWindowTitle("地址分配策略")
        layout = QtWidgets.QVBoxLayout(self)
        self.combo = QtWidgets.QComboBox()
        self.combo.addItems(["二分搜索法", "随机冲突解析", "预分配映射"])
        layout.addWidget(self.combo)
        self.btn_run = QtWidgets.QPushButton("模拟执行")
        layout.addWidget(self.btn_run)
        self.out = QtWidgets.QPlainTextEdit()
        self.out.setReadOnly(True)
        layout.addWidget(self.out)
        self.btn_run.clicked.connect(self._simulate)

    def _simulate(self):
        idx = self.combo.currentIndex()
        msg = ["执行：二分搜索法", "执行：随机冲突解析", "执行：预分配映射"][idx]
        self.out.appendPlainText(msg)


===== END FILE: app/experimental/panel_addr_alloc.py =====

===== FILE: app/experimental/panel_gateway_scan.py =====
# app/experimental/panel_gateway_scan.py
from __future__ import annotations

from PySide6 import QtWidgets


class GatewayScanDialog(QtWidgets.QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("扫描网关")
        self.resize(480, 360)
        layout = QtWidgets.QVBoxLayout(self)
        self.table = QtWidgets.QTableWidget(0, 3, self)
        self.table.setHorizontalHeaderLabels(["ID", "IP", "状态"])
        layout.addWidget(self.table)
        btns = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel,
            parent=self,
        )
        layout.addWidget(btns)
        btns.accepted.connect(self.accept)
        btns.rejected.connect(self.reject)

        form = QtWidgets.QFormLayout()
        self.edt_timeout = QtWidgets.QSpinBox()
        self.edt_timeout.setRange(1, 60)
        self.edt_timeout.setValue(5)
        self.chk_autoscan = QtWidgets.QCheckBox("扫描后自动搜灯")
        layout.insertLayout(0, form)
        form.addRow("超时(s)", self.edt_timeout)
        form.addRow("", self.chk_autoscan)

        self._dummy_fill()

    def _dummy_fill(self):
        # placeholder; real impl should probe network
        self.table.setRowCount(1)
        self.table.setItem(0, 0, QtWidgets.QTableWidgetItem("GW-0001"))
        self.table.setItem(0, 1, QtWidgets.QTableWidgetItem("192.168.1.100"))
        self.table.setItem(0, 2, QtWidgets.QTableWidgetItem("在线"))


===== END FILE: app/experimental/panel_gateway_scan.py =====

===== FILE: app/experimental/panel_timecontrol.py =====
# app/experimental/panel_timecontrol.py
from __future__ import annotations

from PySide6 import QtCore, QtWidgets


class TimeControlPanel(QtWidgets.QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setObjectName("PanelTimeControl")
        self.setWindowTitle("时序/时间表")
        layout = QtWidgets.QVBoxLayout(self)
        self.table = QtWidgets.QTableWidget(0, 4, self)
        self.table.setHorizontalHeaderLabels(["启用", "时间", "目标", "动作"])
        layout.addWidget(self.table)
        bar = QtWidgets.QToolBar()
        act_add = bar.addAction("添加时序")
        act_del = bar.addAction("删除所选")
        layout.addWidget(bar)
        act_add.triggered.connect(self._add_row)
        act_del.triggered.connect(self._del_row)

    def _add_row(self):
        row = self.table.rowCount()
        self.table.insertRow(row)
        chk = QtWidgets.QTableWidgetItem()
        chk.setCheckState(QtCore.Qt.Checked)
        self.table.setItem(row, 0, chk)
        self.table.setItem(row, 1, QtWidgets.QTableWidgetItem("08:00"))
        self.table.setItem(row, 2, QtWidgets.QTableWidgetItem("组1"))
        self.table.setItem(row, 3, QtWidgets.QTableWidgetItem("开灯至50%"))

    def _del_row(self):
        rows = {index.row() for index in self.table.selectedIndexes()}
        for row in sorted(rows, reverse=True):
            self.table.removeRow(row)


===== END FILE: app/experimental/panel_timecontrol.py =====

===== FILE: app/extensions/boot.py =====
# app/extensions/boot.py
from __future__ import annotations
import logging
import os, sys, traceback
from PySide6 import QtWidgets, QtGui, QtCore

# Optional i18n
try:
    from app.i18n import i18n
except Exception:  # pragma: no cover
    class _I:
        def t(self, k, fallback=None):
            return fallback or k

        def translate_text(self, text):
            return text

        @property
        def lang(self):
            return "zh"

        @lang.setter
        def lang(self, _v):
            pass

    i18n = _I()


def _tr(text: str) -> str:
    try:
        return i18n.translate_text(text)
    except Exception:
        return text

def _apply_light_theme():
    app = QtWidgets.QApplication.instance()
    if app is None:
        return
    try:
        import qdarktheme
        qdarktheme.setup_theme("light")
    except Exception:
        pass
    pal = app.palette()
    pal.setColor(QtGui.QPalette.Window, QtGui.QColor(255,255,255))
    pal.setColor(QtGui.QPalette.WindowText, QtGui.QColor(0,0,0))
    pal.setColor(QtGui.QPalette.Base, QtGui.QColor(255,255,255))
    pal.setColor(QtGui.QPalette.Text, QtGui.QColor(0,0,0))
    app.setPalette(pal)

def _ensure_menu_bar(win: QtWidgets.QMainWindow):
    mb = win.menuBar()
    return mb or QtWidgets.QMenuBar(win)

def _install_language_menu(win: QtWidgets.QMainWindow):
    mb = _ensure_menu_bar(win)
    lang_menu = None
    for m in mb.findChildren(QtWidgets.QMenu):
        if m.title() in ("语言", "Language", _tr("语言"), _tr("Language")):
            lang_menu = m; break
    if lang_menu is None:
        lang_menu = mb.addMenu(_tr(i18n.t("menu.language", "语言")))
    else:
        lang_menu.setTitle(_tr(i18n.t("menu.language", lang_menu.title())))

    act_zh = QtGui.QAction(_tr(i18n.t("menu.language.zh", "中文")), win)
    act_en = QtGui.QAction(_tr(i18n.t("menu.language.en", "English")), win)

    def set_lang(lang):
        def _f():
            i18n.load(lang)
            win.setWindowTitle(_tr(i18n.t("app.title", win.windowTitle())))
            _apply_language_to_ui(win)
        return _f
    act_zh.triggered.connect(set_lang("zh"))
    act_en.triggered.connect(set_lang("en"))
    lang_menu.clear()
    lang_menu.addAction(act_zh); lang_menu.addAction(act_en)

def _install_tools_scan(win: QtWidgets.QMainWindow):
    mb = _ensure_menu_bar(win)
    tools_menu = None
    for m in mb.findChildren(QtWidgets.QMenu):
        if m.title() in ("工具", "Tools", _tr("工具"), _tr("Tools")):
            tools_menu = m; break
    if tools_menu is None:
        tools_menu = mb.addMenu(_tr(i18n.t("menu.tools", "工具")))
    else:
        tools_menu.setTitle(_tr(i18n.t("menu.tools", tools_menu.title())))

    act_scan = QtGui.QAction(_tr(i18n.t("menu.tools.scan_gateways", "扫描网关...")), win)

    def open_scan():
        try:
            from app.experimental.panel_gateway_scan import GatewayScanDialog
        except Exception:
            QtWidgets.QMessageBox.warning(win, _tr("缺失"), _tr("panel_gateway_scan 未找到"))
            return
        dlg = GatewayScanDialog(parent=win)
        dlg.exec()
    act_scan.triggered.connect(open_scan)
    # Avoid duplicates
    for a in tools_menu.actions():
        if a.text() == act_scan.text():
            return
    tools_menu.addAction(act_scan)

class _LogDock(QtWidgets.QDockWidget):
    def __init__(self, parent=None):
        super().__init__(_tr(i18n.t("menu.view.log_pane", "日志窗格")), parent)
        self.setObjectName("LogDock")
        self.text = QtWidgets.QPlainTextEdit(self)
        self.text.setReadOnly(True)
        self.setWidget(self.text)
        tb = QtWidgets.QToolBar(self)
        act_export = QtGui.QAction(_tr(i18n.t("action.export_logs", "导出日志")), self)
        act_export.triggered.connect(self._export)
        tb.addAction(act_export)
        self.setTitleBarWidget(tb)

    def append(self, msg: str):
        self.text.appendPlainText(msg)

    def _export(self):
        fn, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Export Logs", "dali-logs.txt", "Text (*.txt)")
        if fn:
            with open(fn, "w", encoding="utf-8") as f:
                f.write(self.text.toPlainText())


class _DockLogHandler(logging.Handler):
    def __init__(self, dock: _LogDock):
        super().__init__()
        self._dock = dock

    def set_dock(self, dock: _LogDock):
        self._dock = dock

    def emit(self, record: logging.LogRecord):
        dock = self._dock
        if dock is None:
            return
        try:
            msg = self.format(record)
        except Exception:  # pragma: no cover
            msg = record.getMessage()
        QtCore.QTimer.singleShot(0, lambda m=msg: dock.append(m))


_LOG_HANDLER: _DockLogHandler | None = None


def _install_log_pane(win: QtWidgets.QMainWindow):
    docks = [d for d in win.findChildren(QtWidgets.QDockWidget) if d.objectName() == "LogDock"]
    if docks:
        dock = docks[0]
    else:
        dock = _LogDock(win)
        win.addDockWidget(QtCore.Qt.BottomDockWidgetArea, dock)

    # add a toggle in View menu
    mb = _ensure_menu_bar(win)
    view_menu = None
    for m in mb.findChildren(QtWidgets.QMenu):
        if m.title() in ("视图", "View", _tr("视图"), _tr("View")):
            view_menu = m; break
    if view_menu is None:
        view_menu = mb.addMenu(_tr(i18n.t("menu.view", "视图")))
    else:
        view_menu.setTitle(_tr(i18n.t("menu.view", view_menu.title())))
    if dock.toggleViewAction() not in view_menu.actions():
        view_menu.addAction(dock.toggleViewAction())

    global _LOG_HANDLER
    if _LOG_HANDLER is None:
        handler = _DockLogHandler(dock)
        handler.setLevel(logging.INFO)
        handler.setFormatter(logging.Formatter("%(asctime)s %(levelname)s [%(name)s] %(message)s"))
        logging.getLogger().addHandler(handler)
        _LOG_HANDLER = handler
    else:
        _LOG_HANDLER.set_dock(dock)

    return dock


def _benchmark_to_analysis_bridge():
    # passive bridge: if panels exist, wire a simple signal
    try:
        from app.panels import panel_benchmark as pb, panel_analysis as pa
    except Exception:
        return
    bench = None
    analysis = None
    app = QtWidgets.QApplication.instance()
    for w in app.allWidgets():
        if hasattr(w, "objectName"):
            if getattr(w, "objectName")() == "PanelBenchmark":
                bench = w
            if getattr(w, "objectName")() == "PanelAnalysis":
                analysis = w
    # Fallback: try module-level objects
    if hasattr(pb, "last_csv_path") and hasattr(pa, "load_csv"):
        def on_new_csv(path):
            try:
                pa.load_csv(path)
            except Exception:
                pass
        pb.on_csv_written = on_new_csv  # require panel_benchmark to call this hook

def _install_tree_context(win: QtWidgets.QMainWindow):
    # Best-effort: find a QTreeView/QTreeWidget and attach a context menu
    tree = win.findChild(QtWidgets.QTreeView) or win.findChild(QtWidgets.QTreeWidget)
    if not tree:
        return
    tree.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    def open_menu(pos):
        menu = QtWidgets.QMenu(tree)
        a_new_group = menu.addAction(_tr("新建组"))
        a_new_light = menu.addAction(_tr("新建灯"))
        a_del = menu.addAction(_tr("删除选中"))
        act = menu.exec(tree.viewport().mapToGlobal(pos))
        # Persistence hooks (best-effort placeholders)
        try:
            if act == a_new_group and hasattr(tree, "model"):
                pass
            elif act == a_new_light and hasattr(tree, "model"):
                pass
            elif act == a_del:
                pass
        except Exception:
            traceback.print_exc()
    tree.customContextMenuRequested.connect(open_menu)


def _apply_language_to_ui(win: QtWidgets.QMainWindow):
    """遍历常见控件，将文本替换成当前语言。"""

    def translate_action(action: QtGui.QAction):
        if action is None:
            return
        text = action.text()
        new_text = _tr(text)
        if new_text != text:
            action.setText(new_text)
        tip = action.toolTip()
        if tip:
            new_tip = _tr(tip)
            if new_tip != tip:
                action.setToolTip(new_tip)

    def translate_widget(widget: QtWidgets.QWidget):
        if isinstance(widget, QtWidgets.QTabWidget):
            for idx in range(widget.count()):
                text = widget.tabText(idx)
                new_text = _tr(text)
                if new_text != text:
                    widget.setTabText(idx, new_text)
        elif isinstance(widget, (QtWidgets.QGroupBox, QtWidgets.QDockWidget)):
            text = widget.title() if hasattr(widget, "title") else widget.windowTitle()
            new_text = _tr(text)
            if hasattr(widget, "setTitle"):
                if new_text != text:
                    widget.setTitle(new_text)
            elif hasattr(widget, "setWindowTitle") and new_text != text:
                widget.setWindowTitle(new_text)
        elif isinstance(widget, QtWidgets.QLabel):
            if widget.pixmap() is None:
                text = widget.text()
                if text and not text.startswith("<"):
                    new_text = _tr(text)
                    if new_text != text:
                        widget.setText(new_text)
        elif isinstance(widget, (QtWidgets.QPushButton, QtWidgets.QCheckBox, QtWidgets.QRadioButton, QtWidgets.QToolButton)):
            text = widget.text()
            new_text = _tr(text)
            if new_text != text:
                widget.setText(new_text)
        elif isinstance(widget, QtWidgets.QComboBox):
            for idx in range(widget.count()):
                text = widget.itemText(idx)
                new_text = _tr(text)
                if new_text != text:
                    widget.setItemText(idx, new_text)
        elif isinstance(widget, QtWidgets.QLineEdit):
            placeholder = widget.placeholderText()
            if placeholder:
                new_placeholder = _tr(placeholder)
                if new_placeholder != placeholder:
                    widget.setPlaceholderText(new_placeholder)
        elif isinstance(widget, (QtWidgets.QTextEdit, QtWidgets.QPlainTextEdit)):
            placeholder = widget.placeholderText()
            if placeholder:
                new_placeholder = _tr(placeholder)
                if new_placeholder != placeholder:
                    widget.setPlaceholderText(new_placeholder)
        elif isinstance(widget, QtWidgets.QMenu):
            title = widget.title()
            new_title = _tr(title)
            if new_title != title:
                widget.setTitle(new_title)
            for action in widget.actions():
                translate_action(action)
        elif isinstance(widget, QtWidgets.QTableWidget):
            for col in range(widget.columnCount()):
                item = widget.horizontalHeaderItem(col)
                if item is not None:
                    text = item.text()
                    new_text = _tr(text)
                    if new_text != text:
                        item.setText(new_text)
        elif isinstance(widget, QtWidgets.QTreeWidget):
            header = widget.headerItem()
            if header is not None:
                for col in range(header.columnCount()):
                    text = header.text(col)
                    new_text = _tr(text)
                    if new_text != text:
                        header.setText(col, new_text)

    # 主窗口标题
    win.setWindowTitle(_tr(i18n.t("app.title", win.windowTitle())))

    # 菜单/动作
    for action in win.findChildren(QtGui.QAction):
        translate_action(action)

    # 所有控件
    for widget in win.findChildren(QtWidgets.QWidget):
        translate_widget(widget)
        if hasattr(widget, 'apply_language'):
            try:
                widget.apply_language()
            except Exception:
                traceback.print_exc()

    # 状态栏文本
    status = win.statusBar() if hasattr(win, "statusBar") else None
    if status is not None:
        msg = status.currentMessage()
        if msg:
            new_msg = _tr(msg)
            if new_msg != msg:
                status.showMessage(new_msg)

def install_extensions(globals_dict=None):
    try:
        _apply_light_theme()
    except Exception:
        traceback.print_exc()
    win = QtWidgets.QApplication.activeWindow()
    if not isinstance(win, QtWidgets.QMainWindow):
        # try best effort: pick any QMainWindow
        for w in QtWidgets.QApplication.topLevelWidgets():
            if isinstance(w, QtWidgets.QMainWindow):
                win = w; break
    if not isinstance(win, QtWidgets.QMainWindow):
        return
    try:
        _install_language_menu(win)
        _install_tools_scan(win)
        _install_log_pane(win)
        _benchmark_to_analysis_bridge()
        _install_tree_context(win)
        _apply_language_to_ui(win)
    except Exception:
        traceback.print_exc()

===== END FILE: app/extensions/boot.py =====

===== FILE: app/gui/main_window.py =====
from __future__ import annotations
from PySide6.QtWidgets import (
    QMainWindow, QTabWidget, QStatusBar, QMessageBox, QApplication
)
from PySide6.QtGui import QAction
import logging

from app.core.controller import Controller
from app.core.config import get_app_config
from pathlib import Path
from app.i18n import i18n


def _tr_static(text: str, en_fallback: str | None = None) -> str:
    try:
        lang = getattr(i18n, "lang", "zh")
        if lang == "zh":
            return text
        translated = i18n.translate_text(text)
        if translated == text and en_fallback:
            return en_fallback
        return translated
    except Exception:
        return en_fallback or text

# 面板
from .panels.panel_dimming import PanelDimming
from PySide6.QtWidgets import QWidget  # 占位其余Tab
from .panels.panel_rw import PanelRW
from .panels.panel_groups import PanelGroups
from .panels.panel_scenes import PanelScenes
from .panels.panel_dt8_tc import PanelDt8Tc
from .panels.panel_dt8_color import PanelDt8Color
from .panels.panel_benchmark import PanelBenchmark
from .panels.panel_sender import PanelSender
from .panels.panel_inventory import PanelInventory
from .panels.panel_scheduler import PanelScheduler
from .panels.panel_config_io import PanelConfigIO
from app.core.presets import combined_presets
from app.core.events import bus
from .panels.panel_analysis import PanelAnalysis

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(i18n.t("app.title", _tr_static("DALI上位机")))
        self._log = logging.getLogger("GUI")

        # 配置&控制器
        root_dir = Path(__file__).resolve().parents[2]
        self._cfg = get_app_config(root_dir)
        self.ctrl = Controller(self._cfg)

        self._init_ui()

    def _init_ui(self):
        # 1) 先创建并设置状态栏——后续不再替换
        status = QStatusBar()
        self.setStatusBar(status)

        # 2) 再创建Tab和各个面板，并把 status 传进去
        self.tabs = QTabWidget()
        self.panel_dimming = PanelDimming(self.ctrl, status)
        self.tabs.addTab(self.panel_dimming, _tr_static("调光"))
        self.panel_rw = PanelRW(self.ctrl, status)
        self.tabs.addTab(self.panel_rw, _tr_static("变量读写"))
        tc_cfg = self._cfg.get("tc", {})
        self.tabs.addTab(PanelDt8Tc(self.ctrl, status, tc_cfg), _tr_static("色温（DT8 Tc）"))
        # 色彩（DT8）
        ops_cfg = self._cfg.get("ops", {})
        self.tabs.addTab(PanelScenes(self.ctrl, status), _tr_static("场景管理"))
        self.tabs.addTab(PanelGroups(self.ctrl, status), _tr_static("组管理"))
        root_dir = Path(__file__).resolve().parents[2]
        presets_all = combined_presets(root_dir, self._cfg)
        self.tabs.addTab(PanelDt8Color(self.ctrl, status, ops_cfg, presets_all), _tr_static("色彩（DT8）"))
        self.tabs.addTab(PanelSender(self.ctrl, status, root_dir), _tr_static("指令发送"))
        self.tabs.addTab(PanelInventory(self.ctrl, status, root_dir),_tr_static("设备清单", "Inventory"))

        self.tabs.addTab(PanelBenchmark(self.ctrl, status, root_dir), _tr_static("压力测试"))
        self.tabs.addTab(PanelAnalysis(self.ctrl, status, root_dir), _tr_static("数据分析"))
        self.tabs.addTab(PanelScheduler(self.ctrl, status, root_dir), _tr_static("定时任务"))
        self.tabs.addTab(PanelConfigIO(self.ctrl, status, root_dir, self._cfg), _tr_static("配置导入导出"))
        self.setCentralWidget(self.tabs)

        self._update_status()
        # 工具菜单
        menu_tools = self.menuBar().addMenu(_tr_static("工具"))
        self.act_connect = QAction(_tr_static("连接"), self)
        self.act_connect.triggered.connect(self._on_connect)
        self.act_disconnect = QAction(_tr_static("断开"), self)
        self.act_disconnect.triggered.connect(self._on_disconnect)
        menu_tools.addAction(self.act_connect)
        menu_tools.addAction(self.act_disconnect)

        # 帮助菜单
        menu_help = self.menuBar().addMenu(_tr_static("帮助"))
        act_about = QAction(_tr_static("关于"), self)
        act_about.triggered.connect(self._on_about)
        menu_help.addAction(act_about)

    def _update_status(self):
        st = i18n.t("status.connected", _tr_static("已连接")) if self.ctrl.is_connected() else i18n.t("status.disconnected", _tr_static("未连接"))
        self.statusBar().showMessage(i18n.t("status.message", "状态：{status}").format(status=st))

    def _on_connect(self):
        try:
            self.ctrl.connect()
            bus.connection_changed.emit(True)  # ← 广播“已连接”
            self.statusBar().showMessage(i18n.t("status.connected", _tr_static("已连接")), 1500)
            self._update_status()
        except Exception as e:
            self.statusBar().showMessage(i18n.t("status.connect.failed", "连接失败：{error}").format(error=e), 3000)

    def _on_disconnect(self):
        try:
            self.ctrl.disconnect()
        finally:
            bus.connection_changed.emit(False)  # ← 广播“未连接”
            self.statusBar().showMessage(i18n.t("status.disconnected.brief", _tr_static("已断开")), 1500)
            self._update_status()

    def _on_about(self):
        QMessageBox.information(
            self,
            i18n.t("dialog.about.title", _tr_static("关于")),
            i18n.t("dialog.about.body", _tr_static("DALI上位机（Python + Qt）\\n当前阶段：最小可用闭环（调光)"))
        )

===== END FILE: app/gui/main_window.py =====

===== FILE: app/gui/panels/panel_analysis.py =====
from __future__ import annotations
import json
from pathlib import Path
from typing import List, Dict, Any, Optional

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QGroupBox, QGridLayout, QLabel, QPushButton,
    QFileDialog, QListWidget, QListWidgetItem, QComboBox,
    QSpinBox, QTableWidget, QTableWidgetItem, QHeaderView, QAbstractItemView, QLineEdit
)
from PySide6.QtCore import Qt, QDateTime

from matplotlib import rcParams, font_manager
from matplotlib.font_manager import FontProperties
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure

from app.gui.widgets.base_panel import BasePanel
from app.core.analysis.stats import load_durations_csv, compute_stats, ecdf, RunStats
from app.i18n import i18n


def _tr(text: str) -> str:
    # 当缺少可用中文字体时，退回英文标签避免乱码
    if getattr(i18n, "lang", "zh") == "zh" and not _HAS_CN_FONT:
        return i18n.translate_text_to(text, "en")
    return i18n.translate_text(text)


# ------- Matplotlib：确保中文可显示 -------
_FONT_ROOT = Path(__file__).resolve().parents[2] / "assets" / "fonts"
_FONT_CANDIDATES = [
    _FONT_ROOT / "NotoSansSC-Regular.ttf",
    _FONT_ROOT / "NotoSansSC-Regular.otf",
]
_cn_fonts: List[str] = []
_FONT_PROP: Optional[FontProperties] = None

for font_path in _FONT_CANDIDATES:
    if not font_path.exists():
        continue
    try:
        font_manager.fontManager.addfont(str(font_path))
    except Exception:
        # 注册失败时继续尝试创建 FontProperties 以便后续显式使用
        pass
    try:
        prop = FontProperties(fname=str(font_path))
        try:
            family_name = prop.get_name()
        except Exception:
            continue
    except Exception:
        continue
    _FONT_PROP = prop
    if not family_name:
        family_name = font_path.stem
    if family_name not in _cn_fonts:
        _cn_fonts.append(family_name)
    break

for fallback_name in [
    "Noto Sans SC",
    "Source Han Sans SC",
    "Noto Sans CJK SC",
    "Microsoft YaHei",
    "SimHei",
    "WenQuanYi Micro Hei",
]:
    if fallback_name not in _cn_fonts:
        _cn_fonts.append(fallback_name)

_available_font_names = {f.name for f in font_manager.fontManager.ttflist}
_selected_family: Optional[str] = None
for name in _cn_fonts:
    if name in _available_font_names:
        _selected_family = name
        break

if _FONT_PROP is None and _selected_family:
    try:
        _FONT_PROP = FontProperties(family=_selected_family)
    except Exception:
        _FONT_PROP = None

existing = rcParams.get('font.sans-serif', [])
if not isinstance(existing, list):
    existing = list(existing)
rcParams['font.sans-serif'] = _cn_fonts + [f for f in existing if f not in _cn_fonts]
rcParams['font.family'] = _cn_fonts + ['sans-serif']
rcParams['axes.unicode_minus'] = False  # 避免负号显示成方块

_HAS_CN_FONT = (_FONT_PROP is not None) or (_selected_family is not None)


class MplCanvas(FigureCanvas):
    def __init__(self, parent: Optional[QWidget] = None):
        fig = Figure(figsize=(6, 4), tight_layout=True)
        super().__init__(fig)
        self.ax = fig.add_subplot(111)


class PanelAnalysis(BasePanel):
    """数据分析页：统计 bench CSV 并可视化。"""

    def __init__(self, controller, statusbar, root_dir: Path):
        super().__init__(controller, statusbar)
        self.root_dir = root_dir
        self.bench_dir = self.root_dir / "数据" / "bench"
        self.out_dir = self.root_dir / "数据" / "analysis"
        self.out_dir.mkdir(parents=True, exist_ok=True)

        self._datasets: List[Dict[str, Any]] = []
        self._plot_modes = [
            ("time_series", "时间序列"),
            ("hist", "直方图"),
            ("cdf", "累积分布"),
            ("box", "箱线图"),
        ]

        self._build_ui()
        self._refresh_bench_list()
        self._apply_language_texts()

    # ---------- 构建 UI ----------
    def _build_ui(self):
        root = QVBoxLayout(self)

        # 数据源
        self.box_src = QGroupBox()
        sg = QGridLayout(self.box_src)

        self.list_files = QListWidget()
        self.btn_refresh = QPushButton()
        self.btn_add = QPushButton()
        self.btn_browse = QPushButton()
        self.btn_clear = QPushButton()
        self.ed_dir = QLineEdit(str(self.bench_dir))
        self.ed_dir.setReadOnly(True)
        self.lbl_dir = QLabel()

        self.btn_refresh.clicked.connect(self._refresh_bench_list)
        self.btn_add.clicked.connect(self._add_selected_file)
        self.btn_browse.clicked.connect(self._browse_file)
        self.btn_clear.clicked.connect(self._clear_datasets)

        sg.addWidget(self.lbl_dir, 0, 0)
        sg.addWidget(self.ed_dir, 0, 1, 1, 3)
        sg.addWidget(self.btn_refresh, 0, 4)
        sg.addWidget(self.list_files, 1, 0, 1, 5)
        sg.addWidget(self.btn_add, 2, 3)
        sg.addWidget(self.btn_browse, 2, 4)
        root.addWidget(self.box_src)

        # 图表
        self.box_plot = QGroupBox()
        pg = QGridLayout(self.box_plot)
        self.canvas = MplCanvas(self)
        self.cb_kind = QComboBox()
        for mode_id, label in self._plot_modes:
            self.cb_kind.addItem(label, mode_id)
        self.cb_kind.currentIndexChanged.connect(self._redraw)
        self.sp_bins = QSpinBox(); self.sp_bins.setRange(5, 200); self.sp_bins.setValue(30)
        self.sp_bins.valueChanged.connect(self._redraw)
        self.sp_smooth = QSpinBox(); self.sp_smooth.setRange(1, 200); self.sp_smooth.setValue(1)
        self.sp_smooth.valueChanged.connect(self._redraw)
        self.btn_export_fig = QPushButton()
        self.btn_export_fig.clicked.connect(self._export_png)

        self.lbl_kind = QLabel()
        self.lbl_bins = QLabel()
        self.lbl_smooth = QLabel()

        pg.addWidget(self.lbl_kind, 0, 0)
        pg.addWidget(self.cb_kind, 0, 1)
        pg.addWidget(self.lbl_bins, 0, 2)
        pg.addWidget(self.sp_bins, 0, 3)
        pg.addWidget(self.lbl_smooth, 0, 4)
        pg.addWidget(self.sp_smooth, 0, 5)
        pg.addWidget(self.btn_export_fig, 0, 6)
        pg.addWidget(self.canvas, 1, 0, 1, 7)
        root.addWidget(self.box_plot)

        # 表格
        self.box_stat = QGroupBox()
        tg = QGridLayout(self.box_stat)
        self.table = QTableWidget(0, 11)
        self.table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.table.verticalHeader().setVisible(False)

        self.btn_export_csv = QPushButton()
        self.btn_export_json = QPushButton()
        self.btn_export_csv.clicked.connect(self._export_summary_csv)
        self.btn_export_json.clicked.connect(self._export_summary_json)

        tg.addWidget(self.table, 0, 0, 1, 5)
        tg.addWidget(self.btn_export_csv, 1, 3)
        tg.addWidget(self.btn_export_json, 1, 4)
        root.addWidget(self.box_stat)
        root.addStretch(1)

    # ---------- 语言刷新 ----------
    def _apply_language_texts(self):
        self.box_src.setTitle(_tr("数据源（CSV：index,duration_ms）"))
        self.lbl_dir.setText(_tr("默认目录："))
        self.btn_refresh.setText(_tr("刷新列表"))
        self.btn_add.setText(_tr("添加到对比"))
        self.btn_browse.setText(_tr("浏览 CSV…"))
        self.btn_clear.setText(_tr("清空对比"))

        self.box_plot.setTitle(_tr("图表"))
        self.lbl_kind.setText(_tr("图类型："))
        self.lbl_bins.setText(_tr("直方图分箱数："))
        self.lbl_smooth.setText(_tr("平滑窗口（仅时间序列）："))
        self.btn_export_fig.setText(_tr("导出图像 PNG"))

        self.box_stat.setTitle(_tr("统计指标"))
        headers = [
            _tr("名称"), _tr("样本数"), _tr("总时长(ms)"), _tr("均值(ms)"), _tr("标准差(ms)"),
            _tr("最小(ms)"), _tr("P50(ms)"), _tr("P95(ms)"), _tr("P99(ms)"), _tr("最大(ms)"),
            _tr("近似吞吐(次/秒)")
        ]
        for idx, title in enumerate(headers):
            item = self.table.horizontalHeaderItem(idx)
            if item is None:
                item = QTableWidgetItem()
                self.table.setHorizontalHeaderItem(idx, item)
            item.setText(title)
        self.btn_export_csv.setText(_tr("导出摘要 CSV"))
        self.btn_export_json.setText(_tr("导出摘要 JSON"))

        for idx, (_, label) in enumerate(self._plot_modes):
            self.cb_kind.setItemText(idx, _tr(label))

        # 更新组合框 placeholder
        self.btn_clear.setToolTip(_tr("清空对比"))

        self._refresh_table()  # 重新填充表头在翻译后仍保持
        self._redraw()

    # ---------- 文件列表 ----------
    def _refresh_bench_list(self):
        self.list_files.clear()
        if not self.bench_dir.exists():
            self.bench_dir.mkdir(parents=True, exist_ok=True)
        files = sorted(self.bench_dir.glob("bench_*.csv"), key=lambda p: p.stat().st_mtime, reverse=True)
        for p in files:
            ts = QDateTime.fromSecsSinceEpoch(int(p.stat().st_mtime)).toString("yyyy-MM-dd HH:mm:ss")
            QListWidgetItem(f"{p.name}    [{ts}]", self.list_files)

    def _selected_file_path(self) -> Optional[Path]:
        row = self.list_files.currentRow()
        if row < 0:
            return None
        text = self.list_files.item(row).text().split()[0]
        return self.bench_dir / text

    def _add_selected_file(self):
        path = self._selected_file_path()
        if not path:
            self.show_msg(_tr("请先选择一条 CSV"), 1800)
            return
        self._add_dataset(path)

    def _browse_file(self):
        path_str, _ = QFileDialog.getOpenFileName(self, _tr("选择 CSV"), str(self.bench_dir), "CSV (*.csv)")
        if not path_str:
            return
        self._add_dataset(Path(path_str))

    def _add_dataset(self, path: Path):
        try:
            durs = load_durations_csv(path)
            name = path.stem
            stats = compute_stats(name, durs)
            self._datasets.append({
                "name": name,
                "path": str(path),
                "durations": durs,
                "stats": stats,
            })
            self._refresh_table()
            self._redraw()
            self.show_msg(_tr("已添加：{filename}").format(filename=path.name), 1500)
        except Exception as e:
            self.show_msg(_tr("加载失败：{error}").format(error=e), 4000)

    def _clear_datasets(self):
        self._datasets.clear()
        self._refresh_table()
        self._redraw()

    # ---------- 表格 & 导出 ----------
    def _refresh_table(self):
        self.table.setRowCount(len(self._datasets))
        for r, ds in enumerate(self._datasets):
            st: RunStats = ds["stats"]
            vals = [
                st.name,
                st.count,
                f"{st.total_ms:.1f}",
                f"{st.mean_ms:.3f}",
                f"{st.std_ms:.3f}",
                f"{st.min_ms:.3f}",
                f"{st.p50_ms:.3f}",
                f"{st.p95_ms:.3f}",
                f"{st.p99_ms:.3f}",
                f"{st.max_ms:.3f}",
                f"{st.approx_ops_per_s:.2f}",
            ]
            for c, v in enumerate(vals):
                self.table.setItem(r, c, QTableWidgetItem(str(v)))

    def _export_summary_csv(self):
        if not self._datasets:
            self.show_msg(_tr("无数据可导出"), 1800)
            return
        path, _ = QFileDialog.getSaveFileName(self, _tr("导出摘要 CSV"), str(self.out_dir / "summary.csv"), "CSV (*.csv)")
        if not path:
            return
        headers = [
            "名称", "样本数", "总时长(ms)", "均值(ms)", "标准差(ms)", "最小(ms)",
            "P50(ms)", "P95(ms)", "P99(ms)", "最大(ms)", "近似吞吐(次/秒)",
        ]
        with open(path, "w", encoding="utf-8") as f:
            f.write(",".join(headers) + "\n")
            for ds in self._datasets:
                st: RunStats = ds["stats"]
                row = [
                    st.name,
                    st.count,
                    st.total_ms,
                    st.mean_ms,
                    st.std_ms,
                    st.min_ms,
                    st.p50_ms,
                    st.p95_ms,
                    st.p99_ms,
                    st.max_ms,
                    st.approx_ops_per_s,
                ]
                f.write(",".join(str(x) for x in row) + "\n")
        self.show_msg(_tr("已导出：{path}").format(path=path), 2000)

    def _export_summary_json(self):
        if not self._datasets:
            self.show_msg(_tr("无数据可导出"), 1800)
            return
        path, _ = QFileDialog.getSaveFileName(self, _tr("导出摘要 JSON"), str(self.out_dir / "summary.json"), "JSON (*.json)")
        if not path:
            return
        data = [ds["stats"].to_dict() for ds in self._datasets]
        with open(path, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        self.show_msg(_tr("已导出：{path}").format(path=path), 2000)

    # ---------- 绘图 ----------
    def _redraw(self):
        ax = self.canvas.ax
        ax.clear()

        if not self._datasets:
            ax.set_title(_tr("无数据"))
            self.canvas.draw()
            return

        kind = self.cb_kind.currentData(Qt.ItemDataRole.UserRole)

        def label(text: str) -> str:
            return _tr(text)

        def apply_axis_fonts():
            if _FONT_PROP is not None:
                for tick in list(ax.get_xticklabels()) + list(ax.get_yticklabels()):
                    tick.set_fontproperties(_FONT_PROP)

        if kind == "time_series":
            window = max(1, self.sp_smooth.value())
            for ds in self._datasets:
                durations = ds["durations"]
                ys = self._moving_avg(durations, window) if window > 1 else durations
                xs = list(range(1, len(ys) + 1))
                ax.plot(xs, ys, label=ds["name"])
            ax.set_xlabel(label("序号"), fontproperties=_FONT_PROP)
            ax.set_ylabel(label("时延 (ms)"), fontproperties=_FONT_PROP)
            ax.set_title(label("时间序列"), fontproperties=_FONT_PROP)
            apply_axis_fonts()
        elif kind == "hist":
            for ds in self._datasets:
                ax.hist(ds["durations"], bins=self.sp_bins.value(), alpha=0.5, label=ds["name"])
            ax.set_xlabel(label("时延 (ms)"), fontproperties=_FONT_PROP)
            ax.set_ylabel(label("频数"), fontproperties=_FONT_PROP)
            ax.set_title(label("直方图"), fontproperties=_FONT_PROP)
            apply_axis_fonts()
        elif kind == "cdf":
            for ds in self._datasets:
                xs, ys = ecdf(ds["durations"])
                ax.plot(xs, ys, label=ds["name"])
            ax.set_xlabel(label("时延 (ms)"), fontproperties=_FONT_PROP)
            ax.set_ylabel(label("累计概率"), fontproperties=_FONT_PROP)
            ax.set_title(label("累积分布"), fontproperties=_FONT_PROP)
            apply_axis_fonts()
        elif kind == "box":
            data = [ds["durations"] for ds in self._datasets]
            labels = [ds["name"] for ds in self._datasets]
            ax.boxplot(data, labels=labels, showfliers=True)
            ax.set_ylabel(label("时延 (ms)"), fontproperties=_FONT_PROP)
            ax.set_title(label("箱线图"), fontproperties=_FONT_PROP)
            apply_axis_fonts()
        else:
            ax.set_title(label("无数据"), fontproperties=_FONT_PROP)

        if self._datasets:
            if _FONT_PROP is not None:
                ax.legend(prop=_FONT_PROP)
            else:
                ax.legend()
        self.canvas.draw()

    @staticmethod
    def _moving_avg(vals: List[float], w: int) -> List[float]:
        if w <= 1 or len(vals) <= w:
            return vals
        out: List[float] = []
        acc = sum(vals[:w])
        out.append(acc / w)
        for idx in range(w, len(vals)):
            acc += vals[idx] - vals[idx - w]
            out.append(acc / w)
        return out

    def _export_png(self):
        if not self._datasets:
            self.show_msg(_tr("无图可导出"), 1800)
            return
        kind_label = self.cb_kind.currentText()
        fname = _tr("图_{kind}_{timestamp}.png").format(
            kind=kind_label,
            timestamp=QDateTime.currentDateTime().toString('yyyyMMdd_HHmmss'),
        )
        path, _ = QFileDialog.getSaveFileName(self, _tr("导出图像"), str(self.out_dir / fname), "PNG (*.png)")
        if not path:
            return
        self.canvas.figure.savefig(path, dpi=150)
        self.show_msg(_tr("已导出：{path}").format(path=path), 2000)

    # 供语言切换时调用
    def apply_language(self):
        self._apply_language_texts()

===== END FILE: app/gui/panels/panel_analysis.py =====

===== FILE: app/gui/panels/panel_benchmark.py =====
from __future__ import annotations
import logging
from pathlib import Path
from typing import Dict, Any, Optional

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QGroupBox, QGridLayout, QRadioButton, QSpinBox,
    QDoubleSpinBox, QCheckBox, QLabel, QPushButton, QFileDialog, QComboBox,
    QHBoxLayout
)
from PySide6.QtCore import Qt, QThread, QDateTime

from app.core.bench.worker import BenchPlan, BenchWorker
from app.gui.widgets.base_panel import BasePanel
from app.i18n import tr, trf, i18n


def _bind_text(widget, zh: str, en: str, store: list):
    widget.setProperty("_zh", zh)
    widget.setProperty("_en", en)
    if hasattr(widget, "setTitle"):
        widget.setTitle(tr(zh, en))
    elif hasattr(widget, "setText"):
        widget.setText(tr(zh, en))
    store.append(widget)


def _apply_bound_text(widgets: list):
    lang = getattr(i18n, "lang", "zh")
    for widget in widgets:
        zh = widget.property("_zh")
        en = widget.property("_en")
        if zh is None or en is None:
            continue
        text = tr(zh, en)
        if hasattr(widget, "setTitle"):
            widget.setTitle(text)
        elif hasattr(widget, "setText"):
            widget.setText(text)


class PanelBenchmark(BasePanel):
    """Benchmark panel for stress testing command sequences."""

    def __init__(self, controller, statusbar, root_dir: Path):
        super().__init__(controller, statusbar)
        self._log = logging.getLogger("PanelBenchmark")
        self.root_dir = root_dir
        self._thread: Optional[QThread] = None
        self._worker: Optional[BenchWorker] = None
        self._last_result: Optional[dict] = None
        self._i18n_widgets: list = []
        self._task_items: list[tuple[str, str, str]] = []
        self._build_ui()
        self.apply_language()

    # ------------------------------------------------------------------
    # UI construction
    # ------------------------------------------------------------------
    def _build_ui(self):
        root = QVBoxLayout(self)

        # 地址选择
        self.box_addr = QGroupBox()
        ag = QGridLayout(self.box_addr)
        self.rb_b = QRadioButton(); self.rb_b.setChecked(True)
        self.chk_unaddr = QCheckBox()
        self.rb_s = QRadioButton(); self.sb_s = QSpinBox(); self.sb_s.setRange(0, 63)
        self.rb_g = QRadioButton(); self.sb_g = QSpinBox(); self.sb_g.setRange(0, 15)
        ag.addWidget(self.rb_b, 0, 0); ag.addWidget(self.chk_unaddr, 0, 1)
        ag.addWidget(self.rb_s, 1, 0); ag.addWidget(self.sb_s, 1, 1)
        ag.addWidget(self.rb_g, 2, 0); ag.addWidget(self.sb_g, 2, 1)
        root.addWidget(self.box_addr)

        # 任务与参数
        self.box_task = QGroupBox()
        tg = QGridLayout(self.box_task)
        self.cb_task = QComboBox()
        self._task_items = [
            ("ARC：固定亮度", "ARC: Fixed brightness", "arc_fixed"),
            ("ARC：亮度扫描(lo→hi，步长)", "ARC: Sweep (lo→hi, step)", "arc_sweep"),
            ("场景回放", "Scene recall", "scene_recall"),
            ("DT8：Tc 固定K", "DT8: Fixed Tc", "dt8_tc_fixed"),
            ("DT8：xy 固定", "DT8: Fixed xy", "dt8_xy_fixed"),
            ("DT8：RGBW 固定", "DT8: Fixed RGBW", "dt8_rgbw_fixed"),
        ]
        for zh, _en, key in self._task_items:
            self.cb_task.addItem(zh, key)

        self.sp_arc = QSpinBox(); self.sp_arc.setRange(0, 254); self.sp_arc.setValue(128)
        self.sp_lo = QSpinBox(); self.sp_lo.setRange(0, 254)
        self.sp_hi = QSpinBox(); self.sp_hi.setRange(0, 254); self.sp_hi.setValue(254)
        self.sp_step = QSpinBox(); self.sp_step.setRange(1, 50); self.sp_step.setValue(5)
        self.sp_scene = QSpinBox(); self.sp_scene.setRange(0, 15)
        self.sp_k = QSpinBox(); self.sp_k.setRange(1000, 20000); self.sp_k.setValue(4000)
        self.sp_x = QDoubleSpinBox(); self.sp_x.setDecimals(4); self.sp_x.setRange(0.0, 1.0); self.sp_x.setSingleStep(0.0005); self.sp_x.setValue(0.3130)
        self.sp_y = QDoubleSpinBox(); self.sp_y.setDecimals(4); self.sp_y.setRange(0.0, 1.0); self.sp_y.setSingleStep(0.0005); self.sp_y.setValue(0.3290)
        self.sp_r = QSpinBox(); self.sp_r.setRange(0, 254)
        self.sp_g = QSpinBox(); self.sp_g.setRange(0, 254)
        self.sp_b = QSpinBox(); self.sp_b.setRange(0, 254)
        self.sp_w = QSpinBox(); self.sp_w.setRange(0, 254)
        self.sp_total = QSpinBox(); self.sp_total.setRange(1, 100000); self.sp_total.setValue(100)
        self.sp_interval = QSpinBox(); self.sp_interval.setRange(0, 5000); self.sp_interval.setValue(50); self.sp_interval.setSuffix(" ms")
        self.sp_timeout = QSpinBox(); self.sp_timeout.setRange(0, 5000); self.sp_timeout.setValue(0); self.sp_timeout.setSuffix(" ms")

        self.lbl_task = QLabel("任务：")
        self.lbl_arc = QLabel("ARC：")
        self.lbl_lohi = QLabel("lo/hi/step：")
        self.lbl_scene = QLabel("场景：")
        self.lbl_kelvin = QLabel("Kelvin：")
        self.lbl_xy = QLabel("x / y：")
        self.lbl_rgbw = QLabel("R / G / B / W：")
        self.lbl_total = QLabel("总次数：")
        self.lbl_interval = QLabel("间隔：")
        self.lbl_timeout = QLabel("接收超时（可留0）：")

        row = 0
        tg.addWidget(self.lbl_task, row, 0); tg.addWidget(self.cb_task, row, 1, 1, 3); row += 1
        tg.addWidget(self.lbl_arc, row, 0); tg.addWidget(self.sp_arc, row, 1); row += 1
        tg.addWidget(self.lbl_lohi, row, 0)
        rowbox = QHBoxLayout(); rowbox.addWidget(self.sp_lo); rowbox.addWidget(self.sp_hi); rowbox.addWidget(self.sp_step)
        tg.addLayout(rowbox, row, 1, 1, 3); row += 1
        tg.addWidget(self.lbl_scene, row, 0); tg.addWidget(self.sp_scene, row, 1); row += 1
        tg.addWidget(self.lbl_kelvin, row, 0); tg.addWidget(self.sp_k, row, 1); row += 1
        tg.addWidget(self.lbl_xy, row, 0)
        rowbox2 = QHBoxLayout(); rowbox2.addWidget(self.sp_x); rowbox2.addWidget(self.sp_y)
        tg.addLayout(rowbox2, row, 1, 1, 3); row += 1
        tg.addWidget(self.lbl_rgbw, row, 0)
        rowbox3 = QHBoxLayout()
        for spin in (self.sp_r, self.sp_g, self.sp_b, self.sp_w):
            rowbox3.addWidget(spin)
        tg.addLayout(rowbox3, row, 1, 1, 3); row += 1

        tg.addWidget(self.lbl_total, row, 0); tg.addWidget(self.sp_total, row, 1)
        tg.addWidget(self.lbl_interval, row, 2); tg.addWidget(self.sp_interval, row, 3); row += 1
        tg.addWidget(self.lbl_timeout, row, 0); tg.addWidget(self.sp_timeout, row, 1); row += 1

        self.btn_start = QPushButton()
        self.btn_stop = QPushButton()
        self.btn_export = QPushButton()
        self.btn_stop.setEnabled(False)
        self.btn_export.setEnabled(False)
        self.btn_start.clicked.connect(self._on_start)
        self.btn_stop.clicked.connect(self._on_stop)
        self.btn_export.clicked.connect(self._on_export)
        tg.addWidget(self.btn_start, row, 1); tg.addWidget(self.btn_stop, row, 2); tg.addWidget(self.btn_export, row, 3)

        root.addWidget(self.box_task)

        # 统计信息
        self.box_stat = QGroupBox()
        sg = QGridLayout(self.box_stat)
        self.lb_sent = QLabel("0")
        self.lb_ok = QLabel("0")
        self.lb_err = QLabel("0")
        self.lb_last = QLabel("0.0 ms")
        self.lb_avg = QLabel("0.0 ms")
        self.lb_min = QLabel("0.0 ms")
        self.lb_max = QLabel("0.0 ms")
        self.lbl_sent = QLabel("Sent:")
        self.lbl_ok = QLabel("OK:")
        self.lbl_err = QLabel("Err:")
        self.lbl_last = QLabel("Last:")
        self.lbl_avg = QLabel("Avg:")
        self.lbl_min = QLabel("Min:")
        self.lbl_max = QLabel("Max:")
        sg.addWidget(self.lbl_sent, 0, 0); sg.addWidget(self.lb_sent, 0, 1)
        sg.addWidget(self.lbl_ok, 0, 2); sg.addWidget(self.lb_ok, 0, 3)
        sg.addWidget(self.lbl_err, 0, 4); sg.addWidget(self.lb_err, 0, 5)
        sg.addWidget(self.lbl_last, 1, 0); sg.addWidget(self.lb_last, 1, 1)
        sg.addWidget(self.lbl_avg, 1, 2); sg.addWidget(self.lb_avg, 1, 3)
        sg.addWidget(self.lbl_min, 1, 4); sg.addWidget(self.lb_min, 1, 5)
        sg.addWidget(self.lbl_max, 1, 6); sg.addWidget(self.lb_max, 1, 7)
        root.addWidget(self.box_stat)
        root.addStretch(1)

        # 连接门控
        self.register_send_widgets([self.btn_start])

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------
    def _read_addr(self):
        if self.rb_s.isChecked():
            return "short", self.sb_s.value(), False
        if self.rb_g.isChecked():
            return "group", self.sb_g.value(), False
        return "broadcast", None, self.chk_unaddr.isChecked()

    def _build_plan(self) -> BenchPlan:
        mode, addr_val, unaddr = self._read_addr()
        task = self.cb_task.currentData()
        params: Dict[str, Any] = {}
        if task == "arc_fixed":
            params = {"arc": self.sp_arc.value()}
        elif task == "arc_sweep":
            params = {"lo": self.sp_lo.value(), "hi": self.sp_hi.value(), "step": self.sp_step.value()}
        elif task == "scene_recall":
            params = {"scene": self.sp_scene.value()}
        elif task == "dt8_tc_fixed":
            params = {"kelvin": self.sp_k.value()}
        elif task == "dt8_xy_fixed":
            params = {"x": self.sp_x.value(), "y": self.sp_y.value()}
        elif task == "dt8_rgbw_fixed":
            params = {"r": self.sp_r.value(), "g": self.sp_g.value(), "b": self.sp_b.value(), "w": self.sp_w.value()}
        return BenchPlan(
            mode=mode,
            addr_val=addr_val,
            unaddr=unaddr,
            task=task,
            params=params,
            total=self.sp_total.value(),
            interval_ms=self.sp_interval.value(),
            recv_timeout_ms=self.sp_timeout.value(),
        )

    # ------------------------------------------------------------------
    # Actions
    # ------------------------------------------------------------------
    def _on_start(self):
        if self._thread and self._thread.isRunning():
            return
        plan = self._build_plan()
        worker = BenchWorker(self.ctrl, plan, self.root_dir)
        worker.signals.status.connect(self._on_status)
        worker.signals.finished.connect(self._on_finished)
        worker.signals.error.connect(self._on_error)

        thread = QThread()
        worker.moveToThread(thread)
        thread.started.connect(worker.run)
        worker.signals.finished.connect(thread.quit)
        worker.signals.finished.connect(worker.deleteLater)
        thread.finished.connect(thread.deleteLater)

        self._worker = worker
        self._thread = thread
        self.btn_start.setEnabled(False)
        self.btn_stop.setEnabled(True)
        self.btn_export.setEnabled(False)
        self.show_msg(tr("压力测试开始", "Stress test started"), 1500)
        thread.start()

    def _on_stop(self):
        if self._worker:
            self._worker.stop()
            self.show_msg(tr("正在停止…", "Stopping..."), 1200)
        self.btn_stop.setEnabled(False)

    def _on_status(self, payload: dict):
        self.lb_sent.setText(str(payload.get("sent", 0)))
        self.lb_ok.setText(str(payload.get("ok", 0)))
        self.lb_err.setText(str(payload.get("err", 0)))
        self.lb_last.setText(f"{payload.get('last_ms', 0.0):.1f} ms")
        self.lb_avg.setText(f"{payload.get('avg_ms', 0.0):.1f} ms")
        self.lb_min.setText(f"{payload.get('min_ms', 0.0):.1f} ms")
        self.lb_max.setText(f"{payload.get('max_ms', 0.0):.1f} ms")
        tooltip = payload.get("last_log")
        if tooltip:
            self.lb_last.setToolTip(tooltip)

    def _on_finished(self, result: dict):
        self._last_result = result
        self.btn_start.setEnabled(True)
        self.btn_stop.setEnabled(False)
        self.btn_export.setEnabled(bool(result))
        self.show_msg(tr("压力测试完成", "Stress test finished"), 2000)

    def _on_error(self, message: str):
        self.show_msg(trf("加载任务失败：{error}", "Benchmark error: {error}", error=message), 4000)
        self.btn_start.setEnabled(True)
        self.btn_stop.setEnabled(False)
        self.btn_export.setEnabled(False)

    def _on_export(self):
        if not self._last_result:
            return
        default = self.root_dir / "数据" / "bench" / f"bench_{i18n.lang}_{QDateTime.currentDateTime().toString('yyyyMMdd_HHmmss')}.csv"
        default.parent.mkdir(parents=True, exist_ok=True)
        path, _ = QFileDialog.getSaveFileName(self, tr("导出CSV", "Export CSV"), str(default), "CSV (*.csv)")
        if not path:
            return
        header = ["timestamp", "sent", "ok", "err", "avg_ms", "min_ms", "max_ms"]
        rows = self._last_result.get("rows", [])
        lines = [",".join(header)]
        for row in rows:
            lines.append(
                ",".join(str(row.get(key, "")) for key in header)
            )
        with open(path, "w", encoding="utf-8") as f:
            f.write("\n".join(lines))
        self.show_msg(trf("已导出：{path}", "Exported to {path}", path=path), 2000)

    # ------------------------------------------------------------------
    # Language
    # ------------------------------------------------------------------
    def apply_language(self):
        _bind_text(self.box_addr, "地址选择", "Address selection", self._i18n_widgets)
        _bind_text(self.rb_b, "广播", "Broadcast", self._i18n_widgets)
        _bind_text(self.chk_unaddr, "仅未寻址", "Not addressed only", self._i18n_widgets)
        _bind_text(self.rb_s, "短地址", "Short address", self._i18n_widgets)
        _bind_text(self.rb_g, "组地址", "Group address", self._i18n_widgets)

        _bind_text(self.box_task, "压力任务", "Stress tasks", self._i18n_widgets)
        _bind_text(self.lbl_task, "任务：", "Task:", self._i18n_widgets)
        _bind_text(self.lbl_arc, "ARC：", "ARC:", self._i18n_widgets)
        _bind_text(self.lbl_lohi, "lo/hi/step：", "lo/hi/step:", self._i18n_widgets)
        _bind_text(self.lbl_scene, "场景：", "Scene:", self._i18n_widgets)
        _bind_text(self.lbl_kelvin, "Kelvin：", "Kelvin:", self._i18n_widgets)
        _bind_text(self.lbl_xy, "x / y：", "x / y:", self._i18n_widgets)
        _bind_text(self.lbl_rgbw, "R / G / B / W：", "R / G / B / W:", self._i18n_widgets)
        _bind_text(self.lbl_total, "总次数：", "Total count:", self._i18n_widgets)
        _bind_text(self.lbl_interval, "间隔：", "Interval:", self._i18n_widgets)
        _bind_text(self.lbl_timeout, "接收超时（可留0）：", "Receive timeout (leave 0 to skip):", self._i18n_widgets)
        _bind_text(self.btn_start, "开始", "Start", self._i18n_widgets)
        _bind_text(self.btn_stop, "停止", "Stop", self._i18n_widgets)
        _bind_text(self.btn_export, "导出CSV", "Export CSV", self._i18n_widgets)

        _bind_text(self.box_stat, "实时统计", "Real-time statistics", self._i18n_widgets)
        _bind_text(self.lbl_sent, "Sent:", "Sent:", self._i18n_widgets)
        _bind_text(self.lbl_ok, "OK:", "OK:", self._i18n_widgets)
        _bind_text(self.lbl_err, "Err:", "Errors:", self._i18n_widgets)
        _bind_text(self.lbl_last, "Last:", "Last:", self._i18n_widgets)
        _bind_text(self.lbl_avg, "Avg:", "Avg:", self._i18n_widgets)
        _bind_text(self.lbl_min, "Min:", "Min:", self._i18n_widgets)
        _bind_text(self.lbl_max, "Max:", "Max:", self._i18n_widgets)

        # Combo items
        for index, (zh, en, _key) in enumerate(self._task_items):
            self.cb_task.setItemText(index, tr(zh, en))

        _apply_bound_text(self._i18n_widgets)

===== END FILE: app/gui/panels/panel_benchmark.py =====

===== FILE: app/gui/panels/panel_config_io.py =====
from __future__ import annotations
from pathlib import Path
from typing import Optional

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QGroupBox, QGridLayout, QLabel, QPushButton,
    QFileDialog, QCheckBox, QLineEdit, QTextEdit
)

from app.core.io.state_io import load_state, save_state, empty_template, StateFile
from app.core.io.apply import apply_groups, apply_scenes
from app.core.presets import load_user_presets, save_user_presets
from app.i18n import tr, trf


class PanelConfigIO(QWidget):
    """Import/export of group/scene/DT8 presets."""

    def __init__(self, controller, statusbar, root_dir: Path, cfg: dict):
        super().__init__()
        self.ctrl = controller
        self.statusbar = statusbar
        self.root_dir = root_dir
        self.cfg = cfg
        self._loaded: Optional[StateFile] = None

        self._build_ui()
        self.apply_language()

    # ------------------------------------------------------------------
    def _build_ui(self):
        root = QVBoxLayout(self)

        # Import section
        self.box_in = QGroupBox()
        ig = QGridLayout(self.box_in)

        self.le_path = QLineEdit()
        self.btn_browse = QPushButton()
        self.chk_groups = QCheckBox()
        self.chk_clear_others = QCheckBox()
        self.chk_scenes = QCheckBox()
        self.chk_recall = QCheckBox()
        self.chk_presets = QCheckBox()
        self.btn_apply = QPushButton()

        self.btn_browse.clicked.connect(self._browse)
        self.btn_apply.clicked.connect(self._apply)

        ig.addWidget(self.le_path, 0, 0, 1, 3)
        ig.addWidget(self.btn_browse, 0, 3)
        ig.addWidget(self.chk_groups, 1, 0)
        ig.addWidget(self.chk_clear_others, 1, 1)
        ig.addWidget(self.chk_scenes, 2, 0)
        ig.addWidget(self.chk_recall, 2, 1)
        ig.addWidget(self.chk_presets, 3, 0)
        ig.addWidget(self.btn_apply, 4, 3)
        root.addWidget(self.box_in)

        # Export section
        self.box_out = QGroupBox()
        og = QGridLayout(self.box_out)

        self.btn_tpl = QPushButton()
        self.btn_preset = QPushButton()
        self.lbl_info = QLabel()
        self.te_info = QTextEdit(); self.te_info.setReadOnly(True)

        self.btn_tpl.clicked.connect(self._export_template)
        self.btn_preset.clicked.connect(self._export_presets)

        og.addWidget(self.btn_tpl, 0, 0)
        og.addWidget(self.btn_preset, 0, 1)
        og.addWidget(self.lbl_info, 1, 0, 1, 2)
        og.addWidget(self.te_info, 2, 0, 1, 2)
        root.addWidget(self.box_out)
        root.addStretch(1)

    # ------------------------------------------------------------------
    def apply_language(self):
        self.box_in.setTitle(tr("导入并应用", "Import and apply"))
        self.le_path.setPlaceholderText(tr("选择一个 JSON 文件…", "Select a JSON file..."))
        self.btn_browse.setText(tr("浏览…", "Browse..."))
        self.chk_groups.setText(tr("应用 组成员关系", "Apply group memberships"))
        self.chk_clear_others.setText(tr("应用组时清空未列出组", "Clear unlisted groups when applying"))
        self.chk_scenes.setText(tr("应用 场景亮度表", "Apply scene brightness table"))
        self.chk_recall.setText(tr("写入场景后回放验证", "Playback verification after writing"))
        self.chk_presets.setText(tr("导入 DT8 预设（写入用户预设文件）", "Import DT8 presets (write to user preset files)"))
        self.btn_apply.setText(tr("导入并应用", "Import and apply"))

        self.box_out.setTitle(tr("导出", "Export"))
        self.btn_tpl.setText(tr("导出空模板", "Export empty template"))
        self.btn_preset.setText(tr("导出当前预设", "Export current preset"))
        self.lbl_info.setText(tr("最近一次导入解析信息：", "Latest import parse info:"))

    # ------------------------------------------------------------------
    def _show(self, zh: str, en: str, ms: int = 2000, **kwargs):
        message = trf(zh, en, **kwargs)
        try:
            self.statusbar.showMessage(message, ms)
        except Exception:
            pass

    def _browse(self):
        path, _ = QFileDialog.getOpenFileName(
            self,
            tr("选择 JSON", "Choose JSON"),
            str(self.root_dir),
            "JSON (*.json)",
        )
        if not path:
            return
        self.le_path.setText(path)
        try:
            state = load_state(Path(path))
            self._loaded = state
            self._render_info(state)
            self._show("已加载 JSON", "JSON loaded", 1200)
        except Exception as exc:
            self._loaded = None
            self.te_info.setPlainText(trf("解析失败：{error}", "Parse failed: {error}", error=exc))
            self._show("解析失败", "Parse failed", 2000)

    def _render_info(self, state: StateFile):
        lines = [f"version: {state.version}"]
        lines.append(trf("groups: {count} 条", "groups: {count}", count=len(state.groups)))
        lines.append(trf("scenes: {count} 条", "scenes: {count}", count=len(state.scenes)))
        lines.append(trf("dt8_presets: {count} 条", "dt8_presets: {count}", count=len(state.dt8_presets)))
        for entry in state.groups[:5]:
            lines.append(f"  short {entry.short} -> groups {entry.groups}")
        for entry in state.scenes[:5]:
            lines.append(f"  short {entry.short} -> levels {entry.levels}")
        for preset in state.dt8_presets[:5]:
            lines.append(f"  preset: {preset.get('name')}")
        self.te_info.setPlainText('\n'.join(lines))

    def _apply(self):
        if not self._loaded:
            self._show("请先加载 JSON", "Load the JSON file first", 2000)
            return
        state = self._loaded
        if self.chk_groups.isChecked() and state.groups:
            apply_groups(self.ctrl, state.groups, clear_others=self.chk_clear_others.isChecked())
        if self.chk_scenes.isChecked() and state.scenes:
            apply_scenes(self.ctrl, state.scenes, recall_after_store=self.chk_recall.isChecked())
        if self.chk_presets.isChecked() and state.dt8_presets is not None:
            user_path = self.root_dir / "数据" / "presets.json"
            save_user_presets(user_path, state.dt8_presets)
        self._show("导入/应用完成", "Import/apply complete", 2500)

    def _export_template(self):
        path, _ = QFileDialog.getSaveFileName(
            self,
            tr("导出空模板", "Export empty template"),
            str(self.root_dir / "数据" / "state_template.json"),
            "JSON (*.json)",
        )
        if not path:
            return
        save_state(Path(path), empty_template())
        self._show("已导出空模板", "Empty template exported", 1500)

    def _export_presets(self):
        user_path = self.root_dir / "数据" / "presets.json"
        presets = load_user_presets(user_path) or self.cfg.get("presets", [])
        state = empty_template()
        state.dt8_presets = presets
        path, _ = QFileDialog.getSaveFileName(
            self,
            tr("导出当前预设", "Export current preset"),
            str(self.root_dir / "数据" / "presets_export.json"),
            "JSON (*.json)",
        )
        if not path:
            return
        save_state(Path(path), state)
        self._show("已导出当前预设", "Current preset exported", 1500)

===== END FILE: app/gui/panels/panel_config_io.py =====

===== FILE: app/gui/panels/panel_dimming.py =====
from __future__ import annotations
import logging
from PySide6.QtWidgets import (
    QLabel,
    QPushButton,
    QVBoxLayout,
    QSlider,
    QGroupBox,
    QGridLayout,
    QSpinBox,
)
from PySide6.QtCore import Qt
from app.gui.widgets.base_panel import BasePanel
from app.gui.widgets.address_target import AddressTargetWidget
from app.i18n import tr, trf


class PanelDimming(BasePanel):
    """
    基本调光（ARC 0..254）：
    - 地址选择（广播/短址/组址）
    - 滑条 + 数字框联动
    - 快捷：最暗/中间/最亮
    - 发送
    """
    def __init__(self, controller, statusbar):
        super().__init__(controller, statusbar)
        self._log = logging.getLogger("PanelDimming")
        self._build_ui()

    # ---------- UI ----------
    def _build_ui(self):
        root = QVBoxLayout(self)

        self.addr_widget = AddressTargetWidget(self)
        root.addWidget(self.addr_widget)

        # 调光区
        self.box_dim = QGroupBox()
        dg = QGridLayout(self.box_dim)
        self.slider = QSlider(Qt.Horizontal); self.slider.setRange(0, 254); self.slider.setValue(128)
        self.spin = QSpinBox(); self.spin.setRange(0, 254); self.spin.setValue(128)
        # 双向联动
        self.slider.valueChanged.connect(self.spin.setValue)
        self.spin.valueChanged.connect(self.slider.setValue)

        self.btn_min = QPushButton()
        self.btn_mid = QPushButton()
        self.btn_max = QPushButton()
        self.btn_send = QPushButton()

        # 快捷：先同步 UI，再发送
        def _set_and_send(v: int):
            self.spin.setValue(int(v))
            self._send_arc(int(v))

        self.btn_min.clicked.connect(lambda: _set_and_send(0))
        self.btn_mid.clicked.connect(lambda: _set_and_send(128))
        self.btn_max.clicked.connect(lambda: _set_and_send(254))
        self.btn_send.clicked.connect(lambda: self._send_arc(self.spin.value()))

        self.lbl_brightness = QLabel()
        dg.addWidget(self.lbl_brightness, 0, 0)
        dg.addWidget(self.slider, 0, 1, 1, 3)
        dg.addWidget(self.spin,   0, 4)
        dg.addWidget(self.btn_min, 1, 1)
        dg.addWidget(self.btn_mid, 1, 2)
        dg.addWidget(self.btn_max, 1, 3)
        dg.addWidget(self.btn_send, 1, 4)
        root.addWidget(self.box_dim)
        root.addStretch(1)

        # 连接门控：未连接时禁用发送类按钮
        self.register_send_widgets([self.btn_send, self.btn_min, self.btn_mid, self.btn_max])

        self.apply_language()

    # ---------- helpers ----------
    # ---------- actions ----------
    def _send_arc(self, val: int):
        # 确保UI一致
        if self.spin.value() != val:
            self.spin.setValue(int(val))
        mode = self.addr_widget.mode()
        addr_val = self.addr_widget.addr_value()
        unaddr = self.addr_widget.unaddressed()
        try:
            self.ctrl.send_arc(mode, int(val), addr_val=addr_val, unaddr=unaddr)
            self.show_msg(trf("已发送 ARC={value}", "Sent ARC={value}", value=int(val)), 2000)
        except Exception as e:
            self._log.error(tr("发送ARC失败", "ARC send failed"), exc_info=True)
            self.show_msg(trf("发送失败：{error}", "Send failed: {error}", error=e), 5000)

    # ---------- language ----------
    def apply_language(self):
        self.addr_widget.apply_language()

        self.box_dim.setTitle(tr("亮度（ARC 0–254）", "Brightness (ARC 0–254)"))
        self.lbl_brightness.setText(tr("亮度：", "Brightness:"))
        self.btn_min.setText(tr("最暗(0)", "Darkest (0)"))
        self.btn_mid.setText(tr("中间(128)", "Middle (128)"))
        self.btn_max.setText(tr("最亮(254)", "Brightest (254)"))
        self.btn_send.setText(tr("发送", "Send"))

===== END FILE: app/gui/panels/panel_dimming.py =====

===== FILE: app/gui/panels/panel_dt8_color.py =====
from __future__ import annotations
import logging
from typing import Dict, List, Any
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QGroupBox,
    QGridLayout,
    QLabel,
    QPushButton,
    QTabWidget,
    QDoubleSpinBox,
    QSpinBox,
    QSlider,
)
from PySide6.QtCore import Qt
from app.gui.widgets.base_panel import BasePanel
from app.gui.widgets.address_target import AddressTargetWidget
from app.i18n import tr, trf, i18n


class PanelDt8Color(BasePanel):
    """DT8 色彩：xy 与 RGBW 两种方式 + 预设色板"""
    def __init__(self, controller, statusbar, ops_cfg: dict | None = None, presets: List[dict] | None = None):
        super().__init__(controller, statusbar)
        self._log = logging.getLogger("PanelDt8Color")
        self.ops_cfg = ops_cfg or {}
        self.presets = presets or []
        self._rgbw: Dict[str, tuple[QSlider, QSpinBox, QPushButton]] = {}
        self._send_buttons: List[QPushButton] = []  # 用于连接门控
        self._build_ui()

    # ---------- UI ----------
    def _build_ui(self):
        root = QVBoxLayout(self)

        self.addr_widget = AddressTargetWidget(self)
        root.addWidget(self.addr_widget)

        # Tabs：xy / RGBW
        self.tabs = QTabWidget()
        self.xy_tab = self._build_xy_tab()
        self.rgbw_tab = self._build_rgbw_tab()
        self.tabs.addTab(self.xy_tab, "xy")
        self.tabs.addTab(self.rgbw_tab, "RGBW")
        root.addWidget(self.tabs)

        # 预设色板
        self.presets_box = self._build_presets()
        root.addWidget(self.presets_box)
        root.addStretch(1)

        # 连接门控：注册所有发送类按钮
        self.register_send_widgets(self._send_buttons)

    def _addr(self):
        return (
            self.addr_widget.mode(),
            self.addr_widget.addr_value(),
            self.addr_widget.unaddressed(),
        )

    # ---------- xy ----------
    def _build_xy_tab(self):
        w = QWidget(); g = QGridLayout(w)
        self.sp_x = QDoubleSpinBox(); self.sp_y = QDoubleSpinBox()
        for sp in (self.sp_x, self.sp_y):
            sp.setDecimals(4); sp.setRange(0.0, 1.0); sp.setSingleStep(0.0005)
        self.sp_x.setValue(0.313); self.sp_y.setValue(0.329)  # 近似D65
        self.lbl_x = QLabel()
        self.lbl_y = QLabel()
        self.btn_set_xy = QPushButton()
        self.btn_set_xy.clicked.connect(self._apply_xy)
        g.addWidget(self.lbl_x, 0, 0); g.addWidget(self.sp_x, 0, 1)
        g.addWidget(self.lbl_y, 0, 2); g.addWidget(self.sp_y, 0, 3)
        g.addWidget(self.btn_set_xy, 0, 4)
        self._send_buttons.append(self.btn_set_xy)
        return w

    def _apply_xy(self):
        mode, addr_val, unaddr = self._addr()
        x, y = self.sp_x.value(), self.sp_y.value()
        try:
            out = self.ctrl.dt8_set_xy(mode, x, y, addr_val=addr_val, unaddr=unaddr)
            self.show_msg(
                trf(
                    "已设置 xy=({x:.4f},{y:.4f}) → ({ux},{uy})",
                    "Set xy=({x:.4f},{y:.4f}) → ({ux},{uy})",
                    x=out['x'], y=out['y'], ux=out['x_u16'], uy=out['y_u16']
                ),
                2500,
            )
        except Exception as e:
            self.show_msg(trf("失败：{error}", "Failed: {error}", error=e), 5000)

    # ---------- RGBW ----------
    def _build_rgbw_tab(self):
        w = QWidget(); g = QGridLayout(w)

        self._rgbw_labels: Dict[str, QLabel] = {}

        def add_channel_row(row: int, label: str):
            slider = QSlider(Qt.Horizontal); slider.setRange(0, 254); slider.setValue(0)
            spin   = QSpinBox(); spin.setRange(0, 254)
            slider.valueChanged.connect(spin.setValue)
            spin.valueChanged.connect(slider.setValue)
            btn = QPushButton()
            btn.clicked.connect(lambda l=label: self._apply_single_primary(l.lower()))
            lbl = QLabel()
            g.addWidget(lbl,    row, 0)
            g.addWidget(slider, row, 1, 1, 2)
            g.addWidget(spin,   row, 3)
            g.addWidget(btn,    row, 4)
            self._rgbw[label.lower()] = (slider, spin, btn)
            self._rgbw_labels[label.lower()] = lbl
            self._send_buttons.append(btn)

        # 固定通道
        row = 0
        for ch in ["R", "G", "B", "W"]:
            add_channel_row(row, ch); row += 1
        # 额外通道（如配置定义了 a/f）
        prim = (self.ops_cfg.get("dt8_set_primary") or {})
        for ch in ["A", "F"]:
            if ch.lower() in prim:
                add_channel_row(row, ch); row += 1

        self.btn_all = QPushButton()
        self.btn_all.clicked.connect(self._apply_all_rgbw)
        g.addWidget(self.btn_all, row, 3)
        self._send_buttons.append(self.btn_all)
        return w

    def _apply_single_primary(self, ch: str):
        mode, addr_val, unaddr = self._addr()
        _, spin, _btn = self._rgbw[ch]
        val = spin.value()
        try:
            out = self.ctrl.dt8_set_primary(mode, ch, val, addr_val=addr_val, unaddr=unaddr)
            self.show_msg(
                trf("已设置 {channel}={level}", "Set {channel}={level}", channel=ch.upper(), level=out['level']),
                2000,
            )
        except Exception as e:
            self.show_msg(trf("失败：{error}", "Failed: {error}", error=e), 5000)

    def _apply_all_rgbw(self):
        mode, addr_val, unaddr = self._addr()
        try:
            for ch, (_sl, sp, _btn) in self._rgbw.items():
                self.ctrl.dt8_set_primary(mode, ch, sp.value(), addr_val=addr_val, unaddr=unaddr)
            self.show_msg(tr("已发送全部通道", "All channels sent"), 2000)
        except Exception as e:
            self.show_msg(trf("失败：{error}", "Failed: {error}", error=e), 5000)

    # ---------- 预设色板 ----------
    def _build_presets(self):
        box = QGroupBox()
        g = QGridLayout(box)
        col_per_row = 4
        if not self.presets:
            self.lbl_no_preset = QLabel("（在 配置/dali.yaml 的 presets: 添加你的色板，或导入 JSON）")
            g.addWidget(self.lbl_no_preset, 0, 0, 1, 4)
            return box

        self.preset_buttons: List[QPushButton] = []
        for i, p in enumerate(self.presets):
            original = p.get("name", f"预设{i+1}")
            btn = QPushButton(original)
            btn.setProperty("preset_name", original)
            btn.clicked.connect(lambda _=False, preset=p: self._apply_preset(preset))
            r, c = divmod(i, col_per_row)
            g.addWidget(btn, r, c)
            self._send_buttons.append(btn)
            self.preset_buttons.append(btn)
        return box

    def _apply_preset(self, p: Dict[str, Any]):
        mode, addr_val, unaddr = self._addr()
        try:
            m = (p.get("mode") or "").lower()
            if m == "rgbw":
                vals = p.get("values", {})
                for ch, (sl, sp, _btn) in self._rgbw.items():
                    if ch in vals:
                        sp.setValue(int(vals[ch]))
                for ch, val in vals.items():
                    if ch in self._rgbw:
                        self.ctrl.dt8_set_primary(mode, ch, int(val), addr_val=addr_val, unaddr=unaddr)
                self.show_msg(trf("已应用预设：{name}", "Preset applied: {name}", name=p.get('name')), 2200)
            elif m == "xy":
                vals = p.get("values", {})
                x, y = float(vals.get("x", 0.313)), float(vals.get("y", 0.329))
                self.sp_x.setValue(x); self.sp_y.setValue(y)
                self.ctrl.dt8_set_xy(mode, x, y, addr_val=addr_val, unaddr=unaddr)
                self.show_msg(trf("已应用预设：{name} (xy)", "Preset applied: {name} (xy)", name=p.get('name')), 2200)
            elif m == "tc":
                k = int(p.get("kelvin", 4000))
                out = self.ctrl.dt8_set_tc_kelvin(mode, k, addr_val=addr_val, unaddr=unaddr)
                self.show_msg(trf("已应用预设：{name}（{kelvin}K）", "Preset applied: {name} ({kelvin}K)", name=p.get('name'), kelvin=out['kelvin']), 2200)
            else:
                self.show_msg(tr("未知预设类型", "Unknown preset type"), 3000)
        except Exception as e:
            self.show_msg(trf("预设失败：{error}", "Preset failed: {error}", error=e), 5000)

    def apply_language(self):
        self.addr_widget.apply_language()

        idx = self.tabs.indexOf(self.xy_tab)
        if idx >= 0:
            self.tabs.setTabText(idx, tr("xy", "xy"))
        idx = self.tabs.indexOf(self.rgbw_tab)
        if idx >= 0:
            self.tabs.setTabText(idx, tr("RGBW", "RGBW"))

        self.lbl_x.setText(tr("x ∈ [0,1]：", "x ∈ [0,1]:"))
        self.lbl_y.setText(tr("y ∈ [0,1]：", "y ∈ [0,1]:"))
        self.btn_set_xy.setText(tr("设置 xy", "Set xy"))

        channel_labels = {
            "r": ("R：", "R:"),
            "g": ("G：", "G:"),
            "b": ("B：", "B:"),
            "w": ("W：", "W:"),
            "a": ("A：", "A:"),
            "f": ("F：", "F:"),
        }
        for ch, lbl in self._rgbw_labels.items():
            zh, en = channel_labels.get(ch, (f"{ch.upper()}：", f"{ch.upper()}:"))
            lbl.setText(tr(zh, en))
        for ch, (_slider, _spin, btn) in self._rgbw.items():
            btn.setText(tr(f"发送{ch.upper()}", f"Send {ch.upper()}"))

        self.btn_all.setText(tr("发送全部", "Send all"))

        self.presets_box.setTitle(tr("预设色板", "Preset color palette"))
        if hasattr(self, "lbl_no_preset"):
            self.lbl_no_preset.setText(tr("（在 配置/dali.yaml 的 presets: 添加你的色板，或导入 JSON）",
                                         "(Add palettes in config/dali.yaml presets or import JSON)"))

        preset_map = {
            "红": "Red",
            "绿": "Green",
            "蓝": "Blue",
            "暖白(2700K)": "Warm white (2700K)",
            "中性白(4000K)": "Neutral white (4000K)",
            "冷白(6500K)": "Cool white (6500K)",
            "演示红": "Demo red",
        }
        for btn in getattr(self, "preset_buttons", []):
            orig = btn.property("preset_name") or btn.text()
            if getattr(i18n, "lang", "zh") == "en":
                btn.setText(preset_map.get(orig, orig))
            else:
                btn.setText(orig)

===== END FILE: app/gui/panels/panel_dt8_color.py =====

===== FILE: app/gui/panels/panel_dt8_tc.py =====
from __future__ import annotations
import logging
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QGroupBox,
    QGridLayout,
    QSpinBox,
    QLabel,
    QPushButton,
    QSlider,
)
from PySide6.QtCore import Qt
from app.gui.widgets.base_panel import BasePanel
from app.gui.widgets.address_target import AddressTargetWidget
from app.i18n import tr, trf


class PanelDt8Tc(BasePanel):
    """DT8 / Tc 色温控制（以 Kelvin 输入，内部换算 Mirek）"""
    def __init__(self, controller, statusbar, tc_cfg: dict | None = None):
        super().__init__(controller, statusbar)
        self._log = logging.getLogger("PanelDt8Tc")
        self.tc_cfg = tc_cfg or {}
        self._build_ui()

    def _build_ui(self):
        root = QVBoxLayout(self)

        self.addr_widget = AddressTargetWidget(self)
        root.addWidget(self.addr_widget)

        # Tc 设置
        kmin = int(self.tc_cfg.get("kelvin_min", 1700))
        kmax = int(self.tc_cfg.get("kelvin_max", 8000))
        self.box_tc = QGroupBox()
        tg = QGridLayout(self.box_tc)
        self.slider = QSlider(Qt.Horizontal); self.slider.setRange(kmin, kmax)
        self.spinK  = QSpinBox(); self.spinK.setRange(kmin, kmax); self.spinK.setValue(4000)
        self.spinM  = QSpinBox(); self.spinM.setRange(1, 65534); self.spinM.setReadOnly(True)

        # 同步 & 初始换算
        self.slider.valueChanged.connect(self.spinK.setValue)
        self.spinK.valueChanged.connect(self.slider.setValue)
        self.spinK.valueChanged.connect(self._update_mirek)
        self._update_mirek(self.spinK.value())

        self.btn_send = QPushButton()
        self.btn_send.clicked.connect(self._on_send)

        self.lbl_k = QLabel()
        self.lbl_m = QLabel()
        tg.addWidget(self.lbl_k, 0, 0); tg.addWidget(self.slider, 0, 1, 1, 4); tg.addWidget(self.spinK, 0, 5)
        tg.addWidget(self.lbl_m, 1, 0); tg.addWidget(self.spinM, 1, 1)
        tg.addWidget(self.btn_send, 1, 5)
        root.addWidget(self.box_tc)
        root.addStretch(1)

        # 连接门控
        self.register_send_widgets([self.btn_send])

    def _update_mirek(self, k: int):
        try:
            m = max(1, min(65534, int(round(1_000_000 / float(k)))))
            self.spinM.blockSignals(True)
            self.spinM.setValue(m)
            self.spinM.blockSignals(False)
        except Exception:
            pass

    def _on_send(self):
        mode = self.addr_widget.mode()
        addr_val = self.addr_widget.addr_value()
        unaddr = self.addr_widget.unaddressed()
        k = self.spinK.value()
        try:
            out = self.ctrl.dt8_set_tc_kelvin(mode, k, addr_val=addr_val, unaddr=unaddr)
            self.show_msg(trf("已设置 Tc={kelvin}K（{mirek} Mirek）", "Set Tc={kelvin}K ({mirek} Mirek)", kelvin=out['kelvin'], mirek=out['mirek']), 2500)
        except Exception as e:
            self.show_msg(trf("失败：{error}", "Failed: {error}", error=e), 5000)

    def apply_language(self):
        self.addr_widget.apply_language()

        self.box_tc.setTitle(tr("色温（Kelvin）→ Mirek", "Color temperature (Kelvin) → Mirek"))
        self.lbl_k.setText(tr("K：", "K:"))
        self.lbl_m.setText(tr("Mirek：", "Mirek:"))
        self.btn_send.setText(tr("设置色温", "Set color temperature"))

===== END FILE: app/gui/panels/panel_dt8_tc.py =====

===== FILE: app/gui/panels/panel_groups.py =====
from __future__ import annotations
import logging
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QGroupBox,
    QGridLayout,
    QSpinBox,
    QLabel,
    QPushButton,
)
from app.gui.widgets.base_panel import BasePanel
from app.gui.widgets.address_target import AddressTargetWidget
from app.i18n import tr, trf


class PanelGroups(BasePanel):
    """组管理：加入/移除 group(0..15)。"""
    def __init__(self, controller, statusbar):
        super().__init__(controller, statusbar)
        self._log = logging.getLogger("PanelGroups")
        self._build_ui()

    def _build_ui(self):
        root = QVBoxLayout(self)

        self.addr_widget = AddressTargetWidget(self)
        root.addWidget(self.addr_widget)

        # 组操作
        self.box_grp = QGroupBox()
        gg = QGridLayout(self.box_grp)
        self.sb_group = QSpinBox(); self.sb_group.setRange(0, 15)
        self.btn_add = QPushButton()
        self.btn_del = QPushButton()
        self.btn_add.clicked.connect(lambda: self._do("add"))
        self.btn_del.clicked.connect(lambda: self._do("remove"))

        self.lbl_group = QLabel()
        gg.addWidget(self.lbl_group, 0, 0); gg.addWidget(self.sb_group, 0, 1)
        gg.addWidget(self.btn_add, 0, 2); gg.addWidget(self.btn_del, 0, 3)
        root.addWidget(self.box_grp)
        root.addStretch(1)

        # 连接门控
        self.register_send_widgets([self.btn_add, self.btn_del])

        self.apply_language()

    def _do(self, action: str):
        mode = self.addr_widget.mode()
        addr_val = self.addr_widget.addr_value()
        unaddr = self.addr_widget.unaddressed()
        g = self.sb_group.value()
        try:
            if action == "add":
                self.ctrl.group_add(mode, g, addr_val=addr_val, unaddr=unaddr)
                self.show_msg(trf("已加入组{group}", "Added to group {group}", group=g), 2000)
            else:
                self.ctrl.group_remove(mode, g, addr_val=addr_val, unaddr=unaddr)
                self.show_msg(trf("已从组{group}移除", "Removed from group {group}", group=g), 2000)
        except Exception as e:
            self._log.error(tr("组操作失败", "Group operation failed"), exc_info=True)
            self.show_msg(trf("失败：{error}", "Failed: {error}", error=e), 5000)

    def apply_language(self):
        self.addr_widget.apply_language()
        self.addr_widget.setTitle(tr("目标选择（建议为短地址或广播）", "Target selection (recommended for short or broadcast)"))

        self.box_grp.setTitle(tr("组操作", "Group operation"))
        self.lbl_group.setText(tr("组号(0–15)：", "Group (0–15):"))
        self.btn_add.setText(tr("加入组", "Join group"))
        self.btn_del.setText(tr("从组移除", "Remove from group"))

===== END FILE: app/gui/panels/panel_groups.py =====

===== FILE: app/gui/panels/panel_inventory.py =====
from __future__ import annotations

import json
from pathlib import Path
from typing import Dict, List

from PySide6.QtCore import Qt, QDateTime
from PySide6.QtWidgets import (
    QFileDialog,
    QGroupBox,
    QHBoxLayout,
    QPushButton,
    QTabWidget,
    QTableWidget,
    QTableWidgetItem,
    QVBoxLayout,
    QWidget,
)

from app.gui.widgets.base_panel import BasePanel
from app.i18n import tr, trf


class PanelInventory(BasePanel):
    """设备读回与导出面板。"""

    def __init__(self, controller, statusbar, root_dir: Path):
        super().__init__(controller, statusbar)
        self.root_dir = root_dir
        self._devices: Dict[int, Dict[str, object]] = {}

        self._build_ui()
        self.apply_language()

    # ------------------ UI ------------------
    def _build_ui(self):
        root = QVBoxLayout(self)

        self.box_actions = QGroupBox()
        act_layout = QHBoxLayout(self.box_actions)
        self.btn_scan = QPushButton()
        self.btn_groups = QPushButton()
        self.btn_scenes = QPushButton()
        self.btn_export = QPushButton()

        act_layout.addWidget(self.btn_scan)
        act_layout.addWidget(self.btn_groups)
        act_layout.addWidget(self.btn_scenes)
        act_layout.addStretch(1)
        act_layout.addWidget(self.btn_export)

        self.btn_scan.clicked.connect(self._scan_devices)

        self.btn_groups.clicked.connect(self._read_groups)
        self.btn_scenes.clicked.connect(self._read_scenes)
        self.btn_export.clicked.connect(self._export_json)

        root.addWidget(self.box_actions)

        self.table = QTableWidget(0, 4, self)
        self.table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.table.verticalHeader().setVisible(False)
        root.addWidget(self.table)
        root.addStretch(1)

        self.register_send_widgets([self.btn_scan, self.btn_groups, self.btn_scenes, self.btn_export])

    # ------------------ Actions ------------------
    def _scan_devices(self):
        found = self.ctrl.scan_devices()
        self._devices = {
            short: {
                "status": True,
                "groups": {},
                "scenes": {},
            }
            for short in found
        }
        self._refresh_table()
        self.show_msg(trf("扫描完成：{count} 台", "Scan finished: {count} device(s)", count=len(found)), 2000)

    def _read_groups(self):
        if not self._devices:
            self.show_msg(tr("请先扫描设备", "Scan devices first"), 2000)
            return
        for short in list(self._devices.keys()):
            groups = self.ctrl.query_groups(short)
            self._devices[short]["groups"] = groups
        self._refresh_table()
        self.show_msg(tr("已读取组成员信息", "Group memberships updated"), 2000)

    def _read_scenes(self):
        if not self._devices:
            self.show_msg(tr("请先扫描设备", "Scan devices first"), 2000)
            return
        for short in list(self._devices.keys()):
            levels = self.ctrl.query_scene_levels(short)
            self._devices[short]["scenes"] = levels
        self._refresh_table()
        self.show_msg(tr("已读取场景亮度", "Scene levels updated"), 2000)

    def _export_json(self):
        if not self._devices:
            self.show_msg(tr("无数据可导出", "No data to export"), 2000)
            return

        data = {
            "version": 1,
            "groups": [],
            "scenes": [],
            "dt8_presets": [],
        }

        for short in sorted(self._devices.keys()):
            info = self._devices[short]
            groups = info.get("groups") or {}
            group_list: List[int] = [g for g, flag in groups.items() if flag]
            if group_list:
                data["groups"].append({"short": short, "groups": group_list})

            levels = info.get("scenes") or {}
            level_map = {str(scene): val for scene, val in levels.items() if val is not None}
            if level_map:
                data["scenes"].append({"short": short, "levels": level_map})

        if not data["groups"] and not data["scenes"]:
            self.show_msg(tr("无有效组/场景数据可导出", "Nothing to export"), 2000)
            return

        default_dir = self.root_dir / "数据"
        default_dir.mkdir(parents=True, exist_ok=True)
        default_name = f"inventory_{QDateTime.currentDateTime().toString('yyyyMMdd_HHmmss')}.json"
        default_path = default_dir / default_name

        path_str, _ = QFileDialog.getSaveFileName(
            self,
            tr("导出 JSON", "Export JSON"),
            str(default_path),
            "JSON (*.json)",
        )
        if not path_str:
            return

        with open(path_str, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        self.show_msg(trf("已导出：{path}", "Exported: {path}", path=path_str), 2000)

    # ------------------ Helpers ------------------
    def _refresh_table(self):
        rows = sorted(self._devices.keys())
        self.table.setRowCount(len(rows))
        headers = [
            tr("短址", "Short"),
            tr("状态", "State"),
            tr("组", "Groups"),
            tr("场景", "Scenes"),
        ]
        for idx, text in enumerate(headers):
            self.table.setHorizontalHeaderItem(idx, QTableWidgetItem(text))

        for row, short in enumerate(rows):
            info = self._devices[short]
            groups = info.get("groups") or {}
            scenes = info.get("scenes") or {}

            self.table.setItem(row, 0, QTableWidgetItem(str(short)))
            self.table.setItem(row, 1, QTableWidgetItem(tr("在线", "Online")))
            self.table.setItem(row, 2, QTableWidgetItem(self._format_groups(groups)))
            self.table.setItem(row, 3, QTableWidgetItem(self._format_scenes(scenes)))

        self.table.resizeColumnsToContents()

    @staticmethod
    def _format_groups(groups: Dict[int, int]) -> str:
        active = [str(idx) for idx, flag in sorted(groups.items()) if flag]
        return ", ".join(active) if active else "-"

    @staticmethod
    def _format_scenes(levels: Dict[int, int | None]) -> str:
        entries = []
        for scene, level in sorted(levels.items()):
            if level is None:
                continue
            entries.append(f"{scene}:{level}")
        return ", ".join(entries) if entries else "-"

    # ------------------ Language ------------------
    def apply_language(self):
        self.box_actions.setTitle(tr("设备操作", "Actions"))
        self.btn_scan.setText(tr("扫描", "Scan"))
        self.btn_groups.setText(tr("读取组", "Read groups"))
        self.btn_scenes.setText(tr("读取场景", "Read scenes"))
        self.btn_export.setText(tr("导出 JSON", "Export JSON"))
        self._refresh_table()

        parent = self.parent()
        while parent is not None and not isinstance(parent, QTabWidget):
            parent = parent.parent()
        if isinstance(parent, QTabWidget):
            idx = parent.indexOf(self)
            if idx >= 0:
                parent.setTabText(idx, tr("设备清单", "Inventory"))

===== END FILE: app/gui/panels/panel_inventory.py =====

===== FILE: app/gui/panels/panel_rw.py =====
from __future__ import annotations
import logging
from PySide6.QtWidgets import (
    QGroupBox,
    QGridLayout,
    QLabel,
    QPushButton,
    QVBoxLayout,
    QLineEdit,
    QSpinBox,
)
from app.gui.widgets.base_panel import BasePanel
from app.gui.widgets.address_target import AddressTargetWidget
from app.i18n import tr, trf


class PanelRW(BasePanel):
    """
    变量读写（自定义命令查询 最小闭环）：
    - 选择地址模式（广播/短址/组址）
    - 输入命令字节（0..255），发送（is_command=1）
    - 尝试接收1字节响应，十六进制与十进制显示
    """
    def __init__(self, controller, statusbar):
        super().__init__(controller, statusbar)
        self._log = logging.getLogger("PanelRW")
        self._build_ui()

    # ---------- UI ----------
    def _build_ui(self):
        root = QVBoxLayout(self)

        self.addr_widget = AddressTargetWidget(self)
        root.addWidget(self.addr_widget)

        # 命令区
        self.box_cmd = QGroupBox()
        cg = QGridLayout(self.box_cmd)
        self.sb_opcode = QSpinBox(); self.sb_opcode.setRange(0, 255); self.sb_opcode.setValue(0x90)
        self.sb_timeout = QSpinBox(); self.sb_timeout.setRange(0, 2000); self.sb_timeout.setValue(300); self.sb_timeout.setSuffix(" ms")
        self.btn_send = QPushButton()
        self.btn_send.clicked.connect(self._on_send)

        self.lbl_opcode = QLabel()
        self.lbl_timeout = QLabel()
        cg.addWidget(self.lbl_opcode, 0, 0); cg.addWidget(self.sb_opcode, 0, 1)
        cg.addWidget(self.lbl_timeout, 0, 2); cg.addWidget(self.sb_timeout, 0, 3)
        cg.addWidget(self.btn_send, 0, 4)
        root.addWidget(self.box_cmd)

        # 结果区
        self.box_out = QGroupBox()
        og = QGridLayout(self.box_out)
        self.le_raw = QLineEdit(); self.le_raw.setReadOnly(True)
        self.le_hex = QLineEdit(); self.le_hex.setReadOnly(True)
        self.le_dec = QLineEdit(); self.le_dec.setReadOnly(True)
        self.lbl_raw = QLabel()
        self.lbl_hex = QLabel()
        self.lbl_dec = QLabel()
        og.addWidget(self.lbl_raw, 0, 0); og.addWidget(self.le_raw, 0, 1, 1, 4)
        og.addWidget(self.lbl_hex, 1, 0); og.addWidget(self.le_hex, 1, 1)
        og.addWidget(self.lbl_dec, 1, 2); og.addWidget(self.le_dec, 1, 3)
        root.addWidget(self.box_out)
        root.addStretch(1)

        # 连接门控：未连接时禁用“发送并接收”
        self.register_send_widgets([self.btn_send])

        self.apply_language()

    # ---------- helpers ----------
    # ---------- actions ----------
    def _on_send(self):
        mode = self.addr_widget.mode()
        addr_val = self.addr_widget.addr_value()
        unaddr = self.addr_widget.unaddressed()
        opcode = self.sb_opcode.value()
        timeout = self.sb_timeout.value() / 1000.0
        try:
            data = self.ctrl.send_command(mode, opcode, addr_val=addr_val, unaddr=unaddr, timeout=timeout)
            if not data:
                self.le_raw.setText("")
                self.le_hex.setText("")
                self.le_dec.setText("")
                self.show_msg(tr("无响应（超时）", "No response (timeout)"), 3000)
                return
            # 展示
            self.le_raw.setText(data.hex(" "))
            self.le_hex.setText(" ".join(f"{b:02X}" for b in data))
            self.le_dec.setText(" ".join(str(int(b)) for b in data))
            self.show_msg(tr("已发送并收到响应", "Command sent and response received"), 2000)
        except Exception as e:
            self._log.error(tr("发送失败", "Send failed"), exc_info=True)
            self.show_msg(trf("发送失败：{error}", "Send failed: {error}", error=e), 5000)

    def apply_language(self):
        self.addr_widget.apply_language()

        self.box_cmd.setTitle(tr("命令查询（is_command=1）", "Command query (is_command=1)"))
        self.lbl_opcode.setText(tr("命令字节 (0–255)：", "Command byte (0–255):"))
        self.lbl_timeout.setText(tr("接收超时：", "Receive timeout:"))
        self.btn_send.setText(tr("发送并接收", "Send and receive"))

        self.box_out.setTitle(tr("响应", "Response"))
        self.lbl_raw.setText(tr("原始字节流：", "Raw bytes:"))
        self.lbl_hex.setText(tr("HEX：", "HEX:"))
        self.lbl_dec.setText(tr("DEC：", "DEC:"))

===== END FILE: app/gui/panels/panel_rw.py =====

===== FILE: app/gui/panels/panel_scenes.py =====
from __future__ import annotations
import logging
from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QGroupBox,
    QGridLayout,
    QSpinBox,
    QLabel,
    QPushButton,
)
from app.gui.widgets.base_panel import BasePanel
from app.gui.widgets.address_target import AddressTargetWidget
from app.i18n import tr, trf


class PanelScenes(BasePanel):
    """场景管理：回放 / 保存（写入亮度）/ 移除。"""
    def __init__(self, controller, statusbar):
        super().__init__(controller, statusbar)
        self._log = logging.getLogger("PanelScenes")
        self._build_ui()

    def _build_ui(self):
        root = QVBoxLayout(self)

        self.addr_widget = AddressTargetWidget(self)
        root.addWidget(self.addr_widget)

        # 场景操作
        self.box_sc = QGroupBox()
        sg = QGridLayout(self.box_sc)
        self.sb_scene = QSpinBox(); self.sb_scene.setRange(0, 15)
        self.sb_level = QSpinBox(); self.sb_level.setRange(0, 254); self.sb_level.setValue(128)

        self.btn_recall = QPushButton()
        self.btn_store  = QPushButton()
        self.btn_remove = QPushButton()

        self.btn_recall.clicked.connect(self._on_recall)
        self.btn_store.clicked.connect(self._on_store)
        self.btn_remove.clicked.connect(self._on_remove)

        self.lbl_scene = QLabel()
        self.lbl_level = QLabel()
        sg.addWidget(self.lbl_scene, 0, 0); sg.addWidget(self.sb_scene, 0, 1)
        sg.addWidget(self.lbl_level, 0, 2); sg.addWidget(self.sb_level, 0, 3)
        sg.addWidget(self.btn_recall, 1, 1); sg.addWidget(self.btn_store, 1, 2); sg.addWidget(self.btn_remove, 1, 3)
        root.addWidget(self.box_sc)
        root.addStretch(1)

        # 连接门控
        self.register_send_widgets([self.btn_recall, self.btn_store, self.btn_remove])

        self.apply_language()

    def _on_recall(self):
        mode = self.addr_widget.mode()
        addr_val = self.addr_widget.addr_value()
        unaddr = self.addr_widget.unaddressed()
        scene = self.sb_scene.value()
        try:
            self.ctrl.scene_recall(mode, scene, addr_val=addr_val, unaddr=unaddr)
            self.show_msg(trf("已回放场景{scene}", "Scene {scene} recalled", scene=scene), 2000)
        except Exception as e:
            self.show_msg(trf("失败：{error}", "Failed: {error}", error=e), 5000)

    def _on_store(self):
        mode = self.addr_widget.mode()
        addr_val = self.addr_widget.addr_value()
        unaddr = self.addr_widget.unaddressed()
        scene = self.sb_scene.value()
        level = self.sb_level.value()
        try:
            self.ctrl.scene_store_level(mode, scene, level, addr_val=addr_val, unaddr=unaddr)
            self.show_msg(trf("已保存 场景{scene} ← 亮度{level}", "Scene {scene} saved with brightness {level}", scene=scene, level=level), 2500)
        except Exception as e:
            self.show_msg(trf("失败：{error}", "Failed: {error}", error=e), 5000)

    def _on_remove(self):
        mode = self.addr_widget.mode()
        addr_val = self.addr_widget.addr_value()
        unaddr = self.addr_widget.unaddressed()
        scene = self.sb_scene.value()
        try:
            self.ctrl.scene_remove(mode, scene, addr_val=addr_val, unaddr=unaddr)
            self.show_msg(trf("已移除 场景{scene}", "Scene {scene} removed", scene=scene), 2000)
        except Exception as e:
            self.show_msg(trf("失败：{error}", "Failed: {error}", error=e), 5000)

    def apply_language(self):
        self.addr_widget.apply_language()

        self.box_sc.setTitle(tr("场景操作", "Scene operation"))
        self.lbl_scene.setText(tr("场景(0–15)：", "Scene (0–15):"))
        self.lbl_level.setText(tr("保存亮度(0–254)：", "Brightness to save (0–254):"))
        self.btn_recall.setText(tr("回放场景", "Recall scene"))
        self.btn_store.setText(tr("保存为场景（写入亮度）", "Store scene (write brightness)"))
        self.btn_remove.setText(tr("移除场景", "Remove scene"))

===== END FILE: app/gui/panels/panel_scenes.py =====

===== FILE: app/gui/panels/panel_scheduler.py =====
from __future__ import annotations
import json
from pathlib import Path
from typing import Optional, Dict, Any
from datetime import datetime

from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QGroupBox, QGridLayout, QRadioButton, QSpinBox,
    QCheckBox, QLabel, QPushButton, QTableWidget, QTableWidgetItem, QHeaderView,
    QLineEdit, QComboBox, QDateTimeEdit, QFileDialog, QHBoxLayout, QAbstractItemView,
    QDoubleSpinBox
)
from PySide6.QtCore import Qt, QDateTime

from app.core.schedule.manager import ScheduleManager, Task
from app.core.utils.hexutil import parse_pairs, fmt_pair
from app.i18n import tr, trf, i18n

WEEK_LABELS = [
    ("Week一", "Week Mon"),
    ("Week二", "Week Tue"),
    ("Week三", "Week Wed"),
    ("Week四", "Week Thu"),
    ("Week五", "Week Fri"),
    ("Week六", "Week Sat"),
    ("Week日", "Week Sun"),
]


class PanelScheduler(QWidget):
    """Task scheduler panel with i18n support."""

    def __init__(self, controller, statusbar, root_dir: Path):
        super().__init__()
        self.ctrl = controller
        self.statusbar = statusbar
        self.root_dir = root_dir
        self.store_dir = root_dir / "数据" / "schedule"
        self.manager = ScheduleManager(controller, self.store_dir, parent=self)
        self._selected_id: Optional[str] = None

        self._action_items: list[tuple[str, str, str]] = []
        self._sched_items: list[tuple[str, str, str]] = []
        self._week_checks: list[QCheckBox] = []

        self._build_ui()
        self._wire_signals()
        self._refresh_table()
        self.apply_language()

    # ------------------------------------------------------------------
    def _build_ui(self):
        root = QVBoxLayout(self)

        # Table
        self.table = QTableWidget(0, 9)
        self.table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        root.addWidget(self.table)

        # Edit area
        self.box_edit = QGroupBox()
        grid = QGridLayout(self.box_edit)

        self.lbl_name = QLabel("任务名称：")
        self.ed_name = QLineEdit()
        self.cb_enabled = QCheckBox("启用")
        grid.addWidget(self.lbl_name, 0, 0); grid.addWidget(self.ed_name, 0, 1, 1, 3); grid.addWidget(self.cb_enabled, 0, 4)

        # Address target
        self.box_addr = QGroupBox()
        ag = QGridLayout(self.box_addr)
        self.rb_b = QRadioButton("广播"); self.rb_b.setChecked(True)
        self.chk_unaddr = QCheckBox("仅未寻址")
        self.rb_s = QRadioButton("短址"); self.sb_s = QSpinBox(); self.sb_s.setRange(0, 63)
        self.rb_g = QRadioButton("组址"); self.sb_g = QSpinBox(); self.sb_g.setRange(0, 15)
        ag.addWidget(self.rb_b, 0, 0); ag.addWidget(self.chk_unaddr, 0, 1)
        ag.addWidget(self.rb_s, 1, 0); ag.addWidget(self.sb_s, 1, 1)
        ag.addWidget(self.rb_g, 2, 0); ag.addWidget(self.sb_g, 2, 1)
        grid.addWidget(self.box_addr, 1, 0, 3, 2)

        # Action parameters
        self.box_action = QGroupBox()
        ag2 = QGridLayout(self.box_action)
        self.cb_action = QComboBox()
        self._action_items = [
            ("ARC 亮度", "ARC brightness", "arc"),
            ("场景回放", "Scene recall", "scene"),
            ("DT8 色温 Tc", "DT8 Tc", "dt8_tc"),
            ("DT8 xy", "DT8 xy", "dt8_xy"),
            ("DT8 RGBW", "DT8 RGBW", "dt8_rgbw"),
            ("原始帧序列", "Raw frame sequence", "raw"),
        ]
        for zh, _en, key in self._action_items:
            self.cb_action.addItem(zh, key)

        self.cb_action.currentIndexChanged.connect(self._on_action_changed)
        self.sp_arc = QSpinBox(); self.sp_arc.setRange(0, 254); self.sp_arc.setValue(128)
        self.sp_scene = QSpinBox(); self.sp_scene.setRange(0, 15)
        self.sp_k = QSpinBox(); self.sp_k.setRange(1000, 20000); self.sp_k.setValue(4000)
        self.sp_x = QDoubleSpinBox(); self.sp_x.setRange(0.0, 1.0); self.sp_x.setDecimals(4); self.sp_x.setSingleStep(0.0005); self.sp_x.setValue(0.3130)
        self.sp_y = QDoubleSpinBox(); self.sp_y.setRange(0.0, 1.0); self.sp_y.setDecimals(4); self.sp_y.setSingleStep(0.0005); self.sp_y.setValue(0.3290)
        self.sp_r = QSpinBox(); self.sp_r.setRange(0, 254)
        self.sp_g = QSpinBox(); self.sp_g.setRange(0, 254)
        self.sp_b = QSpinBox(); self.sp_b.setRange(0, 254)
        self.sp_w = QSpinBox(); self.sp_w.setRange(0, 254)
        self.ed_raw = QLineEdit(); self.ed_raw.setPlaceholderText("示例：\nFF 21\nC1 08\n或：FF 21; C1 08")

        row = 0
        self.lbl_action = QLabel("类型：")
        self.lbl_arc = QLabel("ARC：")
        self.lbl_scene = QLabel("场景：")
        self.lbl_tc = QLabel("Tc K：")
        self.lbl_xy = QLabel("xy：")
        self.lbl_rgbw = QLabel("RGBW：")
        self.lbl_raw = QLabel("原始帧：")

        ag2.addWidget(self.lbl_action, row, 0); ag2.addWidget(self.cb_action, row, 1, 1, 3); row += 1
        ag2.addWidget(self.lbl_arc, row, 0); ag2.addWidget(self.sp_arc, row, 1); row += 1
        ag2.addWidget(self.lbl_scene, row, 0); ag2.addWidget(self.sp_scene, row, 1); row += 1
        ag2.addWidget(self.lbl_tc, row, 0); ag2.addWidget(self.sp_k, row, 1); row += 1
        ag2.addWidget(self.lbl_xy, row, 0)
        self.line_xy = QHBoxLayout(); self.line_xy.addWidget(self.sp_x); self.line_xy.addWidget(self.sp_y)
        ag2.addLayout(self.line_xy, row, 1, 1, 3); row += 1
        ag2.addWidget(self.lbl_rgbw, row, 0)
        self.line_rgbw = QHBoxLayout()
        for spin in (self.sp_r, self.sp_g, self.sp_b, self.sp_w):
            self.line_rgbw.addWidget(spin)
        ag2.addLayout(self.line_rgbw, row, 1, 1, 3); row += 1
        ag2.addWidget(self.lbl_raw, row, 0); ag2.addWidget(self.ed_raw, row, 1, 1, 3)
        grid.addWidget(self.box_action, 1, 2, 3, 3)

        # Scheduling
        self.box_sched = QGroupBox()
        sg = QGridLayout(self.box_sched)
        self.cb_sched = QComboBox()
        self._sched_items = [
            ("一次性", "One-time", "once"),
            ("间隔", "Interval", "interval"),
            ("每天", "Daily", "daily"),
            ("每周", "Weekly", "weekly"),
        ]
        for zh, _en, key in self._sched_items:
            self.cb_sched.addItem(zh, key)
        self.cb_sched.currentIndexChanged.connect(self._on_sched_changed)

        self.lbl_sched_type = QLabel("类型：")
        self.lbl_once = QLabel("一次性：")
        self.dt_once = QDateTimeEdit(QDateTime.currentDateTime())
        self.dt_once.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.dt_once.setCalendarPopup(True)
        self.lbl_interval = QLabel("间隔：")
        self.sp_every = QSpinBox(); self.sp_every.setRange(100, 24 * 60 * 60 * 1000); self.sp_every.setValue(60000); self.sp_every.setSuffix(" ms")
        self.lbl_time = QLabel("时间（用于每天/每周）：")
        self.sp_hour = QSpinBox(); self.sp_hour.setRange(0, 23)
        self.sp_min = QSpinBox(); self.sp_min.setRange(0, 59)
        self.line_time = QHBoxLayout(); self.line_time.addWidget(self.sp_hour); self.line_time.addWidget(self.sp_min)

        row = 0
        sg.addWidget(self.lbl_sched_type, row, 0); sg.addWidget(self.cb_sched, row, 1, 1, 3); row += 1
        sg.addWidget(self.lbl_once, row, 0); sg.addWidget(self.dt_once, row, 1, 1, 3); row += 1
        sg.addWidget(self.lbl_interval, row, 0); sg.addWidget(self.sp_every, row, 1); row += 1
        sg.addWidget(self.lbl_time, row, 0); sg.addLayout(self.line_time, row, 1); row += 1

        line1 = QHBoxLayout(); line2 = QHBoxLayout()
        self._week_checks.clear()
        for index, (zh, _en) in enumerate(WEEK_LABELS):
            chk = QCheckBox(zh)
            (line1 if index < 4 else line2).addWidget(chk)
            self._week_checks.append(chk)
        sg.addLayout(line1, row, 0, 1, 4); row += 1
        sg.addLayout(line2, row, 0, 1, 4)
        grid.addWidget(self.box_sched, 4, 0, 3, 5)

        # Buttons
        self.btn_new = QPushButton("新建")
        self.btn_save = QPushButton("保存")
        self.btn_del = QPushButton("删除")
        self.btn_toggle = QPushButton("启用/禁用")
        self.btn_run = QPushButton("立即执行")
        self.btn_export = QPushButton("导出任务JSON")
        self.btn_import = QPushButton("导入任务JSON")
        btn_box = QHBoxLayout()
        for btn in (self.btn_new, self.btn_save, self.btn_del, self.btn_toggle, self.btn_run, self.btn_export, self.btn_import):
            btn_box.addWidget(btn)
        grid.addLayout(btn_box, 7, 0, 1, 5)

        root.addWidget(self.box_edit)

    # ------------------------------------------------------------------
    def apply_language(self):
        headers = [
            tr("启用", "Enable"),
            tr("名称", "Name"),
            tr("目标", "Target"),
            tr("动作", "Action"),
            tr("参数", "Parameter"),
            tr("调度", "Scheduling"),
            tr("下次运行", "Run next time"),
            tr("上次运行", "Last run"),
            tr("次数", "Count"),
        ]
        for idx, text in enumerate(headers):
            item = self.table.horizontalHeaderItem(idx)
            if item is None:
                item = QTableWidgetItem()
                self.table.setHorizontalHeaderItem(idx, item)
            item.setText(text)

        self.box_edit.setTitle(tr("编辑任务", "Edit Tasks"))
        self.lbl_name.setText(tr("任务名称：", "Task name:"))
        self.cb_enabled.setText(tr("启用", "Enable"))

        self.box_addr.setTitle(tr("目标", "Target"))
        self.rb_b.setText(tr("广播", "Broadcast"))
        self.chk_unaddr.setText(tr("仅未寻址", "Not addressed only"))
        self.rb_s.setText(tr("短址", "Short address"))
        self.rb_g.setText(tr("组址", "Group address"))

        self.box_action.setTitle(tr("动作", "Action"))
        self.lbl_action.setText(tr("类型：", "Type:"))
        self.lbl_arc.setText(tr("ARC：", "ARC:"))
        self.lbl_scene.setText(tr("场景：", "Scene:"))
        self.lbl_tc.setText(tr("Tc K：", "Tc K:"))
        self.lbl_xy.setText(tr("xy：", "xy:"))
        self.lbl_rgbw.setText(tr("RGBW：", "RGBW:"))
        self.lbl_raw.setText(tr("原始帧：", "Raw frames:"))
        self.ed_raw.setPlaceholderText(tr("示例：\nFF 21\nC1 08\n或：FF 21; C1 08", "Example:\nFF 21\nC1 08\nor: FF 21; C1 08"))
        for index, (zh, en, _key) in enumerate(self._action_items):
            self.cb_action.setItemText(index, tr(zh, en))

        self.box_sched.setTitle(tr("调度", "Scheduling"))
        self.lbl_sched_type.setText(tr("类型：", "Type:"))
        self.lbl_once.setText(tr("一次性：", "One-time:"))
        self.lbl_interval.setText(tr("间隔：", "Interval:"))
        self.lbl_time.setText(tr("时间（用于每天/每周）：", "Time (for daily/weekly):"))
        for index, (zh, en, _key) in enumerate(self._sched_items):
            self.cb_sched.setItemText(index, tr(zh, en))
        for chk, (zh, en) in zip(self._week_checks, WEEK_LABELS):
            chk.setText(tr(zh, en))

        self.btn_new.setText(tr("新建", "New"))
        self.btn_save.setText(tr("保存", "Save"))
        self.btn_del.setText(tr("删除", "Delete"))
        self.btn_toggle.setText(tr("启用/禁用", "Enable/disable"))
        self.btn_run.setText(tr("立即执行", "Execute now"))
        self.btn_export.setText(tr("导出任务JSON", "Export task JSON"))
        self.btn_import.setText(tr("导入任务JSON", "Import task JSON"))

    # ------------------------------------------------------------------
    def _wire_signals(self):
        self.manager.task_updated.connect(lambda _tid: self._refresh_table())
        self.manager.tasks_reloaded.connect(self._refresh_table)
        self.manager.message.connect(lambda s: self._show(s, i18n.translate_text(s), 2500))

        self.table.itemSelectionChanged.connect(self._on_select_row)
        self.btn_new.clicked.connect(self._on_new)
        self.btn_save.clicked.connect(self._on_save)
        self.btn_del.clicked.connect(self._on_del)
        self.btn_toggle.clicked.connect(self._on_toggle)
        self.btn_run.clicked.connect(self._on_run)
        self.btn_export.clicked.connect(self._on_export)
        self.btn_import.clicked.connect(self._on_import)

    # ------------------------------------------------------------------
    def _show(self, zh: str, en: str, ms: int = 2000, **kwargs):
        message = trf(zh, en, **kwargs)
        try:
            self.statusbar.showMessage(message, ms)
        except Exception:
            pass

    # ------------------------------------------------------------------
    def _refresh_table(self):
        tasks = self.manager.list()
        self._tasks_cache = tasks
        self.table.setRowCount(len(tasks))
        for row, task in enumerate(tasks):
            values = [
                tr("启用", "Enable") if task.enabled else tr("禁用", "Disable"),
                task.name,
                self._format_target(task),
                self._describe_action(task),
                self._describe_params(task),
                self._describe_schedule(task),
                task.next_run or "-",
                task.last_run or "-",
                str(task.run_count),
            ]
            for col, value in enumerate(values):
                self.table.setItem(row, col, QTableWidgetItem(value))

    def _format_target(self, task: Task) -> str:
        mode_map = {
            "broadcast": tr("广播", "Broadcast"),
            "short": tr("短址", "Short address"),
            "group": tr("组址", "Group address"),
        }
        text = mode_map.get(task.mode, task.mode)
        if task.mode in {"short", "group"} and task.addr_val is not None:
            text += f" #{task.addr_val}"
        if task.mode == "broadcast" and task.unaddr:
            text += f" ({tr('仅未寻址', 'Not addressed only')})"
        return text

    def _describe_action(self, task: Task) -> str:
        name_map = {
            "arc": tr("ARC 亮度", "ARC brightness"),
            "scene": tr("场景回放", "Scene recall"),
            "dt8_tc": tr("DT8 色温 Tc", "DT8 Tc"),
            "dt8_xy": tr("DT8 xy", "DT8 xy"),
            "dt8_rgbw": tr("DT8 RGBW", "DT8 RGBW"),
            "raw": tr("原始帧序列", "Raw frame sequence"),
        }
        return name_map.get(task.action, task.action)

    def _describe_params(self, task: Task) -> str:
        params = task.params or {}
        action = task.action
        if action == "arc":
            return f"ARC={params.get('value', '')}"
        if action == "scene":
            return f"Scene={params.get('scene', '')}"
        if action == "dt8_tc":
            return f"Kelvin={params.get('kelvin', '')}"
        if action == "dt8_xy":
            return f"x={params.get('x', '')}, y={params.get('y', '')}"
        if action == "dt8_rgbw":
            return ", ".join(f"{ch.upper()}={params.get(ch, '')}" for ch in ("r", "g", "b", "w"))
        if action == "raw":
            frames = params.get("frames", [])
            return "; ".join(fmt_pair(*f) for f in frames[:3]) + ("..." if len(frames) > 3 else "")
        return "-"

    def _describe_schedule(self, task: Task) -> str:
        rule = task.schedule or {}
        typ = (rule.get("type") or "").lower()
        if typ == "once":
            return tr("一次性", "One-time") + ": " + (rule.get("datetime") or "-")
        if typ == "interval":
            return tr("间隔", "Interval") + f": {rule.get('every_ms', '')} ms"
        if typ == "daily":
            return tr("每天", "Daily") + f" @ {rule.get('hour', 0):02d}:{rule.get('minute', 0):02d}"
        if typ == "weekly":
            days = rule.get("weekdays", [])
            names = []
            for d in days:
                idx = int(d)
                if 0 <= idx < len(WEEK_LABELS):
                    names.append(tr(*WEEK_LABELS[idx]))
            return tr("每周", "Weekly") + f" {','.join(names)} @ {rule.get('hour', 0):02d}:{rule.get('minute', 0):02d}"
        return "-"

    # ------------------------------------------------------------------
    def _collect_action_params(self) -> Dict[str, Any]:
        action = self.cb_action.currentData()
        if action == "arc":
            return {"value": self.sp_arc.value()}
        if action == "scene":
            return {"scene": self.sp_scene.value()}
        if action == "dt8_tc":
            return {"kelvin": self.sp_k.value()}
        if action == "dt8_xy":
            return {"x": float(self.sp_x.value()), "y": float(self.sp_y.value())}
        if action == "dt8_rgbw":
            return {
                "r": self.sp_r.value(),
                "g": self.sp_g.value(),
                "b": self.sp_b.value(),
                "w": self.sp_w.value(),
            }
        if action == "raw":
            text = self.ed_raw.text().strip()
            if not text:
                return {"frames": []}
            frames = parse_pairs(text)
            return {"frames": [[a, d] for a, d in frames]}
        return {}

    def _apply_action_to_form(self, task: Task):
        params = task.params or {}
        index = self.cb_action.findData(task.action)
        if index >= 0:
            self.cb_action.setCurrentIndex(index)
        if task.action == "arc":
            self.sp_arc.setValue(int(params.get("value", 0)))
        elif task.action == "scene":
            self.sp_scene.setValue(int(params.get("scene", 0)))
        elif task.action == "dt8_tc":
            self.sp_k.setValue(int(params.get("kelvin", 4000)))
        elif task.action == "dt8_xy":
            self.sp_x.setValue(float(params.get("x", 0.313)))
            self.sp_y.setValue(float(params.get("y", 0.329)))
        elif task.action == "dt8_rgbw":
            self.sp_r.setValue(int(params.get("r", 0)))
            self.sp_g.setValue(int(params.get("g", 0)))
            self.sp_b.setValue(int(params.get("b", 0)))
            self.sp_w.setValue(int(params.get("w", 0)))
        elif task.action == "raw":
            frames = params.get("frames", [])
            self.ed_raw.setText("\n".join(fmt_pair(*f) for f in frames))
        self._set_action_fields()

    def _collect_schedule(self) -> Dict[str, Any]:
        typ = self.cb_sched.currentData()
        if typ == "once":
            return {"type": "once", "datetime": self.dt_once.dateTime().toString(Qt.ISODate)}
        if typ == "interval":
            return {"type": "interval", "every_ms": self.sp_every.value()}
        if typ == "daily":
            return {
                "type": "daily",
                "hour": self.sp_hour.value(),
                "minute": self.sp_min.value(),
            }
        if typ == "weekly":
            weekdays = [i for i, chk in enumerate(self._week_checks) if chk.isChecked()]
            return {
                "type": "weekly",
                "hour": self.sp_hour.value(),
                "minute": self.sp_min.value(),
                "weekdays": weekdays,
            }
        return {"type": "once", "datetime": self.dt_once.dateTime().toString(Qt.ISODate)}

    def _apply_schedule_to_form(self, task: Task):
        rule = task.schedule or {}
        typ = rule.get("type", "once")
        index = self.cb_sched.findData(typ)
        if index >= 0:
            self.cb_sched.setCurrentIndex(index)
        if typ == "once":
            dt = rule.get("datetime")
            if dt:
                self.dt_once.setDateTime(QDateTime.fromString(dt, Qt.ISODate))
        elif typ == "interval":
            self.sp_every.setValue(int(rule.get("every_ms", 60000)))
        elif typ in ("daily", "weekly"):
            self.sp_hour.setValue(int(rule.get("hour", 0)))
            self.sp_min.setValue(int(rule.get("minute", 0)))
            if typ == "weekly":
                weekdays = set(int(d) for d in rule.get("weekdays", []))
                for idx, chk in enumerate(self._week_checks):
                    chk.setChecked(idx in weekdays)
        self._set_schedule_fields()

    def _selected_task(self) -> Optional[Task]:
        row = self.table.currentRow()
        if row < 0:
            return None
        if not hasattr(self, "_tasks_cache"):
            return None
        if row >= len(self._tasks_cache):
            return None
        return self._tasks_cache[row]

    def _on_select_row(self):
        task = self._selected_task()
        if not task:
            return
        self._selected_id = task.id
        self.ed_name.setText(task.name)
        self.cb_enabled.setChecked(task.enabled)
        if task.mode == "broadcast":
            self.rb_b.setChecked(True)
        elif task.mode == "short":
            self.rb_s.setChecked(True)
            self.sb_s.setValue(task.addr_val or 0)
        else:
            self.rb_g.setChecked(True)
            self.sb_g.setValue(task.addr_val or 0)
        self.chk_unaddr.setChecked(task.unaddr)

        self._apply_action_to_form(task)
        self._apply_schedule_to_form(task)

    def _clear_form(self):
        self._selected_id = None
        self.ed_name.clear()
        self.cb_enabled.setChecked(True)
        self.rb_b.setChecked(True)
        self.chk_unaddr.setChecked(False)
        self.sp_arc.setValue(128)
        self.sp_scene.setValue(0)
        self.sp_k.setValue(4000)
        self.sp_x.setValue(0.3130)
        self.sp_y.setValue(0.3290)
        self.sp_r.setValue(0)
        self.sp_g.setValue(0)
        self.sp_b.setValue(0)
        self.sp_w.setValue(0)
        self.ed_raw.clear()
        self.cb_action.setCurrentIndex(0)
        self.cb_sched.setCurrentIndex(0)
        for chk in self._week_checks:
            chk.setChecked(False)
        self._set_action_fields()
        self._set_schedule_fields()

    def _on_new(self):
        self._clear_form()
        self.table.clearSelection()

    def _collect_target(self):
        if self.rb_s.isChecked():
            return "short", self.sb_s.value(), False
        if self.rb_g.isChecked():
            return "group", self.sb_g.value(), False
        return "broadcast", None, self.chk_unaddr.isChecked()

    def _on_save(self):
        name = self.ed_name.text().strip()
        if not name:
            self._show("任务名称不能为空", "Task name required", 2000)
            return
        mode, addr_val, unaddr = self._collect_target()
        action = self.cb_action.currentData()
        try:
            params = self._collect_action_params()
        except Exception as exc:
            self._show("原始帧解析失败：{error}", "Raw frame parse failed: {error}", 4000, error=exc)
            return
        schedule = self._collect_schedule()
        enabled = self.cb_enabled.isChecked()

        if self._selected_id:
            self.manager.update(
                self._selected_id,
                name=name,
                enabled=enabled,
                mode=mode,
                addr_val=addr_val,
                unaddr=unaddr,
                action=action,
                params=params,
                schedule=schedule,
            )
            self._show("已保存修改", "Changes saved", 1500)
        else:
            tid = self.manager.create(name, mode, addr_val, unaddr, action, params, schedule, enabled)
            self._selected_id = tid
            self._show("已创建任务", "Task created", 1500)
        self._refresh_table()

    def _on_del(self):
        task = self._selected_task()
        if not task:
            return
        self.manager.delete(task.id)
        self._show("已删除", "Deleted", 1500)
        self._clear_form()
        self._refresh_table()

    def _on_toggle(self):
        task = self._selected_task()
        if not task:
            return
        self.manager.update(task.id, enabled=not task.enabled)
        self._show("启用状态已更新", "Enable state toggled", 1500)
        self._refresh_table()

    def _on_run(self):
        task = self._selected_task()
        if not task:
            return
        self.manager.run_now(task.id)
        self._show("任务执行完成", "Task executed", 1500)
        self._refresh_table()

    def _on_export(self):
        path, _ = QFileDialog.getSaveFileName(
            self,
            tr("导出任务JSON", "Export task JSON"),
            str(self.manager.store_path),
            "JSON (*.json)",
        )
        if not path:
            return
        data = [t.__dict__ for t in self.manager.list()]
        try:
            with open(path, "w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            self._show("已导出", "Exported", 1500)
        except Exception as exc:
            self._show("导出失败：{error}", "Export failed: {error}", 3000, error=exc)

    def _on_import(self):
        path, _ = QFileDialog.getOpenFileName(
            self,
            tr("导入任务JSON", "Import task JSON"),
            str(self.manager.store_path.parent),
            "JSON (*.json)",
        )
        if not path:
            return
        try:
            tasks = json.load(open(path, "r", encoding="utf-8"))
            if not isinstance(tasks, list):
                raise ValueError("JSON 顶层需为列表")
            self.manager._tasks.clear()
            for entry in tasks:
                task = Task(**entry)
                self.manager._tasks[task.id] = task
            self.manager.save()
            self.manager.load()
            self._show("已导入", "Imported", 1500)
            self._refresh_table()
        except Exception as exc:
            self._show("导入失败：{error}", "Import failed: {error}", 3000, error=exc)

    # ------------------------------------------------------------------
    def _set_action_fields(self):
        action = self.cb_action.currentData()
        widgets = {
            "arc": [self.lbl_arc, self.sp_arc],
            "scene": [self.lbl_scene, self.sp_scene],
            "dt8_tc": [self.lbl_tc, self.sp_k],
            "dt8_xy": [self.lbl_xy, self.sp_x, self.sp_y],
            "dt8_rgbw": [self.lbl_rgbw, self.sp_r, self.sp_g, self.sp_b, self.sp_w],
            "raw": [self.lbl_raw, self.ed_raw],
        }
        for key, controls in widgets.items():
            show = key == action
            for ctrl in controls:
                ctrl.setVisible(show)

    def _set_schedule_fields(self):
        typ = self.cb_sched.currentData()
        self.lbl_once.setVisible(typ == "once")
        self.dt_once.setVisible(typ == "once")
        self.lbl_interval.setVisible(typ == "interval")
        self.sp_every.setVisible(typ == "interval")
        time_visible = typ in ("daily", "weekly")
        self.lbl_time.setVisible(time_visible)
        for i in range(self.line_time.count()):
            w = self.line_time.itemAt(i).widget()
            if w:
                w.setVisible(time_visible)
        week_visible = typ == "weekly"
        for chk in self._week_checks:
            chk.setVisible(week_visible)

    def _on_action_changed(self):
        self._set_action_fields()

    def _on_sched_changed(self):
        self._set_schedule_fields()

    # Helper methods (selection, CRUD etc.)
    # ...

===== END FILE: app/gui/panels/panel_scheduler.py =====

===== FILE: app/gui/panels/panel_sender.py =====
from __future__ import annotations
import json
from pathlib import Path
from typing import Optional, List, Dict

from PySide6.QtWidgets import (
    QWidget,
    QVBoxLayout,
    QGridLayout,
    QLabel,
    QPushButton,
    QTabWidget,
    QComboBox,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QFileDialog,
    QTextEdit,
    QSpinBox,
)
from PySide6.QtCore import Qt, QDateTime

from app.gui.widgets.base_panel import BasePanel
from app.gui.widgets.address_target import AddressTargetWidget
from app.core.utils.hexutil import parse_pairs, fmt_pair
from app.core.config import load_yaml
from app.core.dali.frames import addr_broadcast, addr_short, addr_group
from app.i18n import tr, trf


class PanelSender(BasePanel):
    """Command sender: quick commands / raw frames / history."""

    def __init__(self, controller, statusbar, root_dir: Path):
        super().__init__(controller, statusbar)
        self.root_dir = root_dir
        self._commands: List[dict] = []
        self._history: List[dict] = []
        self._history_path = root_dir / "数据" / "sender" / "history.json"
        self._history_path.parent.mkdir(parents=True, exist_ok=True)

        self._build_ui()
        self._load_commands()
        self._load_history()
        self.apply_language()

    # ------------------------------------------------------------------
    # UI construction
    # ------------------------------------------------------------------
    def _build_ui(self):
        root = QVBoxLayout(self)

        self.addr_widget = AddressTargetWidget(self)
        root.addWidget(self.addr_widget)

        # Tabs
        self.tabs = QTabWidget()
        self.tab_quick = self._build_tab_quick()
        self.tab_raw = self._build_tab_raw()
        self.tab_hist = self._build_tab_history()
        self.tabs.addTab(self.tab_quick, "快捷命令")
        self.tabs.addTab(self.tab_raw, "自定义帧")
        self.tabs.addTab(self.tab_hist, "历史记录")
        root.addWidget(self.tabs)
        root.addStretch(1)

        # 连接门控
        self.register_send_widgets([self.btn_send_quick, self.btn_send_raw])

    def _build_tab_quick(self) -> QWidget:
        w = QWidget(); g = QGridLayout(w)
        self.cb_cmd = QComboBox()
        self.sb_param = QSpinBox(); self.sb_param.setRange(0, 255); self.sb_param.setEnabled(False)
        self.le_preview = QLineEdit(); self.le_preview.setReadOnly(True)

        self.cb_cmd.currentIndexChanged.connect(self._on_cmd_changed)
        self.sb_param.valueChanged.connect(self._preview_quick)

        self.btn_send_quick = QPushButton()
        self.btn_send_quick.clicked.connect(self._send_quick)

        self.lbl_cmd = QLabel("命令：")
        self.lbl_param = QLabel("参数：")
        self.lbl_preview = QLabel("预览（addr data）：")

        g.addWidget(self.lbl_cmd, 0, 0); g.addWidget(self.cb_cmd, 0, 1, 1, 3)
        g.addWidget(self.lbl_param, 1, 0); g.addWidget(self.sb_param, 1, 1)
        g.addWidget(self.lbl_preview, 2, 0); g.addWidget(self.le_preview, 2, 1, 1, 3)
        g.addWidget(self.btn_send_quick, 3, 3)
        return w

    def _build_tab_raw(self) -> QWidget:
        w = QWidget(); g = QGridLayout(w)
        self.te_raw = QTextEdit()
        self.lbl_raw_hint = QLabel("两字节帧（多帧用分号或换行分隔）：")
        self.te_raw.setPlaceholderText("示例：\nFF 21\nC1 08\n或：FF 21; C1 08")
        self.btn_send_raw = QPushButton()
        self.btn_send_raw.clicked.connect(self._send_raw_seq)

        g.addWidget(self.lbl_raw_hint, 0, 0, 1, 2)
        g.addWidget(self.te_raw, 1, 0, 1, 2)
        g.addWidget(self.btn_send_raw, 2, 1)
        return w

    def _build_tab_history(self) -> QWidget:
        w = QWidget(); g = QGridLayout(w)
        self.list = QListWidget()
        self.btn_replay = QPushButton()
        self.btn_delete = QPushButton()
        self.btn_clear = QPushButton()
        self.btn_export = QPushButton()
        self.btn_import = QPushButton()

        self.btn_replay.clicked.connect(self._replay)
        self.btn_delete.clicked.connect(self._delete)
        self.btn_clear.clicked.connect(self._clear)
        self.btn_export.clicked.connect(self._export)
        self.btn_import.clicked.connect(self._import)

        g.addWidget(self.list, 0, 0, 1, 5)
        g.addWidget(self.btn_replay, 1, 1)
        g.addWidget(self.btn_delete, 1, 2)
        g.addWidget(self.btn_clear, 1, 3)
        g.addWidget(self.btn_export, 2, 3)
        g.addWidget(self.btn_import, 2, 4)
        return w

    # ------------------------------------------------------------------
    # Shared helpers
    # ------------------------------------------------------------------
    def _addr_byte(self, is_command: bool) -> int:
        mode = self.addr_widget.mode()
        value = self.addr_widget.addr_value()
        unaddr = self.addr_widget.unaddressed()
        if mode == "short" and value is not None:
            return addr_short(value, is_command=is_command)
        if mode == "group" and value is not None:
            return addr_group(value, is_command=is_command)
        return addr_broadcast(is_command=is_command, unaddressed=unaddr)

    def _current_cmd(self) -> Optional[dict]:
        idx = self.cb_cmd.currentIndex()
        if idx < 0 or idx >= len(self._commands):
            return None
        return self._commands[idx]

    # ------------------------------------------------------------------
    # Quick tab logic
    # ------------------------------------------------------------------
    def _on_cmd_changed(self):
        cmd = self._current_cmd()
        if not cmd:
            return
        cmd_type = (cmd.get("type") or "").lower()
        if cmd_type == "base_plus_param":
            self.sb_param.setEnabled(True)
            self.sb_param.setMinimum(int(cmd.get("min", 0)))
            self.sb_param.setMaximum(int(cmd.get("max", 255)))
        else:
            self.sb_param.setEnabled(False)
        self._preview_quick()

    def _preview_quick(self):
        cmd = self._current_cmd()
        if not cmd:
            self.le_preview.clear()
            return
        cmd_type = (cmd.get("type") or "").lower()
        if cmd_type == "arc":
            addr = self._addr_byte(is_command=False)
            data = int(cmd.get("value", 0)) & 0xFF
        elif cmd_type == "base_plus_param":
            addr = self._addr_byte(is_command=True)
            data = (int(cmd.get("base", 0)) + int(self.sb_param.value())) & 0xFF
        else:
            self.le_preview.clear()
            return
        self.le_preview.setText(fmt_pair(addr, data))

    def _send_quick(self):
        cmd = self._current_cmd()
        if not cmd:
            return
        cmd_type = (cmd.get("type") or "").lower()
        if cmd_type == "arc":
            addr = self._addr_byte(is_command=False)
            data = int(cmd.get("value", 0)) & 0xFF
        elif cmd_type == "base_plus_param":
            addr = self._addr_byte(is_command=True)
            data = (int(cmd.get("base", 0)) + int(self.sb_param.value())) & 0xFF
        else:
            self.show_msg(tr("不支持的命令类型", "Unsupported command type"), 2000)
            return

        self.ctrl.send_raw(addr, data)
        label = str(cmd.get("name", "cmd"))
        if cmd_type == "base_plus_param":
            label += f"({self.sb_param.value()})"
        self._push_history([(addr, data)], label)
        self.show_msg(trf("已发送：{frame}", "Sent: {frame}", frame=fmt_pair(addr, data)), 1800)

    # ------------------------------------------------------------------
    # Raw tab logic
    # ------------------------------------------------------------------
    def _send_raw_seq(self):
        text = self.te_raw.toPlainText().strip()
        if not text:
            return
        try:
            pairs = parse_pairs(text)
        except Exception as exc:
            self.show_msg(trf("解析失败：{error}", "Parse failed: {error}", error=exc), 4000)
            return
        for addr, data in pairs:
            self.ctrl.send_raw(addr, data)
        self._push_history(pairs, "RAW")
        self.show_msg(trf("已发送 {count} 帧", "Sent {count} frame(s)", count=len(pairs)), 2000)

    # ------------------------------------------------------------------
    # History tab logic
    # ------------------------------------------------------------------
    def _push_history(self, frames: List[tuple[int, int]], label: str):
        item = {
            "ts": QDateTime.currentDateTime().toString(Qt.ISODate),
            "label": label,
            "frames": [[a, d] for a, d in frames],
        }
        self._history.append(item)
        self._append_item_to_list(item)
        self._save_history()

    def _append_item_to_list(self, item: Dict):
        text = f"[{item['ts']}] {item.get('label', '')}: " + "; ".join(fmt_pair(a, d) for a, d in item["frames"])
        QListWidgetItem(text, self.list)

    def _replay(self):
        row = self.list.currentRow()
        if row < 0:
            return
        item = self._history[row]
        for addr, data in item["frames"]:
            self.ctrl.send_raw(int(addr), int(data))
        self.show_msg(tr("已重放", "Replayed"), 1500)

    def _delete(self):
        row = self.list.currentRow()
        if row < 0:
            return
        del self._history[row]
        self.list.takeItem(row)
        self._save_history()

    def _clear(self):
        self._history.clear()
        self.list.clear()
        self._save_history()

    def _export(self):
        path, _ = QFileDialog.getSaveFileName(
            self,
            tr("导出历史为JSON", "Export history as JSON"),
            str(self._history_path),
            "JSON (*.json)",
        )
        if not path:
            return
        with open(path, "w", encoding="utf-8") as f:
            json.dump(self._history, f, ensure_ascii=False, indent=2)
        self.show_msg(tr("已导出", "Exported"), 1500)

    def _import(self):
        path, _ = QFileDialog.getOpenFileName(
            self,
            tr("导入JSON为历史", "Import JSON as history"),
            str(self._history_path.parent),
            "JSON (*.json)",
        )
        if not path:
            return
        try:
            data = json.load(open(path, "r", encoding="utf-8"))
        except Exception as exc:
            self.show_msg(trf("导入失败：{error}", "Import failed: {error}", error=exc), 4000)
            return
        if not isinstance(data, list):
            self.show_msg(tr("JSON格式应为列表", "JSON must be a list"), 2500)
            return
        self._history.extend(data)
        self.list.clear()
        for item in self._history:
            self._append_item_to_list(item)
        self._save_history()
        self.show_msg(tr("已导入", "Imported"), 1500)

    # ------------------------------------------------------------------
    # Data persistence
    # ------------------------------------------------------------------
    def _load_commands(self):
        path = self.root_dir / "配置" / "commands.yaml"
        if path.exists():
            cfg = load_yaml(path)
            self._commands = list(cfg.get("commands", [])) if cfg else []
        else:
            self._commands = []
        self.cb_cmd.clear()
        for cmd in self._commands:
            self.cb_cmd.addItem(cmd.get("name", "cmd"))
        if self._commands:
            self._on_cmd_changed()

    def _save_history(self):
        try:
            with open(self._history_path, "w", encoding="utf-8") as f:
                json.dump(self._history, f, ensure_ascii=False, indent=2)
        except Exception:
            pass

    def _load_history(self):
        if self._history_path.exists():
            try:
                self._history = json.load(open(self._history_path, "r", encoding="utf-8")) or []
            except Exception:
                self._history = []
        for item in self._history:
            self._append_item_to_list(item)

    # ------------------------------------------------------------------
    # Language refresh
    # ------------------------------------------------------------------
    def apply_language(self):
        self.addr_widget.apply_language()

        idx = self.tabs.indexOf(self.tab_quick)
        if idx >= 0:
            self.tabs.setTabText(idx, tr("快捷命令", "Quick Command"))
        idx = self.tabs.indexOf(self.tab_raw)
        if idx >= 0:
            self.tabs.setTabText(idx, tr("自定义帧", "Custom frames"))
        idx = self.tabs.indexOf(self.tab_hist)
        if idx >= 0:
            self.tabs.setTabText(idx, tr("历史记录", "History"))

        self.lbl_cmd.setText(tr("命令：", "Command:"))
        self.lbl_param.setText(tr("参数：", "Parameter:"))
        self.lbl_preview.setText(tr("预览（addr data）：", "Preview (addr data):"))
        self.btn_send_quick.setText(tr("发送", "Send"))

        self.lbl_raw_hint.setText(tr("两字节帧（多帧用分号或换行分隔）：", "Each frame is two bytes (use semicolon/newline to separate)"))
        self.te_raw.setPlaceholderText(
            tr(
                "示例：\nFF 21\nC1 08\n或：FF 21; C1 08",
                "Example:\nFF 21\nC1 08\nor: FF 21; C1 08",
            )
        )
        self.btn_send_raw.setText(tr("发送帧/序列", "Send frames"))

        self.btn_replay.setText(tr("重放", "Replay"))
        self.btn_delete.setText(tr("删除", "Delete"))
        self.btn_clear.setText(tr("清空", "Clear"))
        self.btn_export.setText(tr("导出JSON", "Export JSON"))
        self.btn_import.setText(tr("导入JSON", "Import JSON"))

===== END FILE: app/gui/panels/panel_sender.py =====

===== FILE: app/gui/widgets/address_target.py =====
from __future__ import annotations

from PySide6.QtCore import Signal
from PySide6.QtWidgets import (
    QCheckBox,
    QGridLayout,
    QGroupBox,
    QRadioButton,
    QSpinBox,
)

from app.i18n import tr


class AddressTargetWidget(QGroupBox):
    """统一的 DALI 寻址选择组件。"""

    changed = Signal()

    def __init__(self, parent=None, title: str | None = None):
        super().__init__(title or tr("地址选择", "Address selection"), parent)

        self.rb_broadcast = QRadioButton(self)
        self.chk_unaddressed = QCheckBox(self)
        self.rb_short = QRadioButton(self)
        self.sb_short = QSpinBox(self)
        self.sb_short.setRange(0, 63)
        self.rb_group = QRadioButton(self)
        self.sb_group = QSpinBox(self)
        self.sb_group.setRange(0, 15)

        layout = QGridLayout(self)
        layout.addWidget(self.rb_broadcast, 0, 0)
        layout.addWidget(self.chk_unaddressed, 0, 1)
        layout.addWidget(self.rb_short, 1, 0)
        layout.addWidget(self.sb_short, 1, 1)
        layout.addWidget(self.rb_group, 2, 0)
        layout.addWidget(self.sb_group, 2, 1)

        self.rb_broadcast.setChecked(True)
        self.chk_unaddressed.setChecked(False)

        # 信号联动
        for widget in (
            self.rb_broadcast,
            self.chk_unaddressed,
            self.rb_short,
            self.rb_group,
        ):
            widget.toggled.connect(self._emit_changed)

        self.sb_short.valueChanged.connect(self._emit_changed)
        self.sb_group.valueChanged.connect(self._emit_changed)

        self.apply_language()

    # ------------------ 公共 API ------------------
    def mode(self) -> str:
        if self.rb_short.isChecked():
            return "short"
        if self.rb_group.isChecked():
            return "group"
        return "broadcast"

    def addr_value(self) -> int | None:
        m = self.mode()
        if m == "short":
            return int(self.sb_short.value())
        if m == "group":
            return int(self.sb_group.value())
        return None

    def unaddressed(self) -> bool:
        return bool(self.chk_unaddressed.isChecked()) if self.mode() == "broadcast" else False

    def set_mode(self, mode: str, value: int | None = None, unaddr: bool = False) -> None:
        mode = (mode or "broadcast").lower()
        if mode == "short":
            self.rb_short.setChecked(True)
            if value is not None:
                self.sb_short.setValue(int(value))
        elif mode == "group":
            self.rb_group.setChecked(True)
            if value is not None:
                self.sb_group.setValue(int(value))
        else:
            self.rb_broadcast.setChecked(True)
            self.chk_unaddressed.setChecked(bool(unaddr))
        self._emit_changed()

    # ------------------ 语言刷新 ------------------
    def apply_language(self) -> None:
        self.setTitle(tr("地址选择", "Address selection"))
        self.rb_broadcast.setText(tr("广播", "Broadcast"))
        self.chk_unaddressed.setText(tr("仅未寻址", "Not addressed only"))
        self.rb_short.setText(tr("短地址", "Short address"))
        self.rb_group.setText(tr("组地址", "Group address"))

    # ------------------ 内部 ------------------
    def _emit_changed(self, *_args) -> None:
        self.changed.emit()


===== END FILE: app/gui/widgets/address_target.py =====

===== FILE: app/gui/widgets/base_panel.py =====
from __future__ import annotations
from typing import Iterable
from PySide6.QtWidgets import QWidget, QStatusBar
from app.core.events import bus
from app.i18n import i18n

class BasePanel(QWidget):
    """
    - show_msg(): 安全状态栏提示（不会因状态栏被替换而崩）
    - register_send_widgets(): 注册需要随“连接状态”启/禁的按钮、输入等
    """
    def __init__(self, controller, statusbar: QStatusBar | None):
        super().__init__()
        self.ctrl = controller
        self._statusbar = statusbar
        self._send_widgets: list[QWidget] = []
        bus.connection_changed.connect(self._on_conn_changed)

    # 统一状态栏提示
    def show_msg(self, text: str, ms: int = 2000):
        try:
            sb = self._statusbar or (self.window().statusBar() if self.window() else None)
            if sb:
                if getattr(i18n, "lang", "zh") == "en":
                    text = i18n.translate_text(text)
                sb.showMessage(text, ms)
        except Exception:
            pass

    # 注册需要“随连接状态启/禁”的控件
    def register_send_widgets(self, widgets: Iterable[QWidget]):
        self._send_widgets.extend(widgets)
        self._on_conn_changed(self.ctrl.is_connected())

    def _on_conn_changed(self, connected: bool):
        for w in self._send_widgets:
            try:
                w.setEnabled(bool(connected))
            except Exception:
                pass

===== END FILE: app/gui/widgets/base_panel.py =====

===== FILE: app/headless.py =====
from __future__ import annotations

import argparse
import signal
import sys
from pathlib import Path

from PySide6.QtCore import QCoreApplication

from app.core.config import get_app_config
from app.core.controller import Controller
from app.core.logging.logger import setup_logging
from app.core.schedule.manager import ScheduleManager
from app.i18n import i18n


def _install_signal_handlers(app: QCoreApplication):
    def _handler(_sig, _frame):  # pragma: no cover - OS signal bridge
        app.quit()

    signal.signal(signal.SIGINT, _handler)
    try:
        signal.signal(signal.SIGTERM, _handler)
    except AttributeError:  # pragma: no cover - Windows 没有 SIGTERM
        pass


def main(argv: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description="LiFud DALI Host headless scheduler")
    parser.add_argument("--lang", choices=("zh", "en"), default="zh")
    parser.add_argument("--load-tasks", default=None, help="任务文件路径，默认使用 数据/schedule/tasks.json")
    parser.add_argument("--run", action="store_true", help="启动事件循环并执行任务")
    parser.add_argument("--no-connect", action="store_true", help="跳过自动连接网关")
    args = parser.parse_args(argv)

    root_dir = Path(__file__).resolve().parents[1]
    log_dir = Path.home() / ".dali_host" / "logs"
    log_dir.mkdir(parents=True, exist_ok=True)
    logger = setup_logging("LiFud-DALI-Headless", log_dir)

    try:
        i18n.load(args.lang)
    except Exception as exc:  # pragma: no cover - i18n 异常只记录
        logger.warning("加载语言包失败：%s", exc)

    app = QCoreApplication(sys.argv if argv is None else [sys.argv[0], *argv])
    app.setApplicationName("LiFud-DALI-Headless")
    _install_signal_handlers(app)

    cfg = get_app_config(root_dir)
    controller = Controller(cfg)

    if not args.no_connect:
        if controller.connect():
            logger.info("网关已连接 (%s)", cfg.get("gateway", {}).get("type", "mock"))
        else:
            logger.warning("网关连接失败，将以未连接状态运行")

    if args.load_tasks:
        store_path = Path(args.load_tasks)
        store_dir = store_path.parent
    else:
        store_dir = root_dir / "数据" / "schedule"
        store_path = store_dir / "tasks.json"

    manager = ScheduleManager(controller, store_dir)
    manager.store_path = store_path
    manager.load()

    manager.message.connect(lambda msg: logger.info("[schedule] %s", msg))

    if not args.run:
        tasks = manager.list()
        if not tasks:
            logger.info("当前没有任务。使用 --run 启动调度循环。")
        else:
            logger.info("当前共 %s 个任务：", len(tasks))
            for task in tasks:
                logger.info("  - %s (enabled=%s, next=%s)", task.name, task.enabled, task.next_run)
        return 0

    logger.info("Headless scheduler running. 按 Ctrl+C 退出。")
    return app.exec()


if __name__ == "__main__":
    sys.exit(main())


===== END FILE: app/headless.py =====

===== FILE: app/i18n.py =====
# app/i18n.py
from __future__ import annotations
import json
import os
import re
from string import Formatter
from typing import Dict, List, Tuple


def _load_json(path: str) -> Dict[str, str]:
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def _compile_pattern(template: str) -> Tuple[re.Pattern[str], List[str]]:
    formatter = Formatter()
    pattern = "^"
    field_names: List[str] = []
    for literal, field_name, _format, _conv in formatter.parse(template):
        if literal:
            pattern += re.escape(literal)
        if field_name is not None:
            slot_name = f"__slot{len(field_names)}__"
            field_names.append(field_name)
            pattern += f"(?P<{slot_name}>.+?)"
    pattern += "$"
    return re.compile(pattern), field_names


def _render_template(template: str, values: Dict[str, str]) -> str:
    formatter = Formatter()
    parts: List[str] = []
    for literal, field_name, _format, _conv in formatter.parse(template):
        if literal:
            parts.append(literal)
        if field_name is not None:
            parts.append(values.get(field_name, values.get(field_name.split(".")[0], "")))
    return "".join(parts)


class I18N:
    def __init__(self, lang: str = "zh", base_dir: str | None = None):
        self.lang = lang
        self.base_dir = base_dir or os.path.join(os.path.dirname(__file__), "..", "i18n")
        self._dicts: Dict[str, Dict[str, str]] = {}
        self._direct_raw: Dict[str, str] = {}
        self._direct_maps: Dict[str, Dict[str, str]] = {"zh": {}, "en": {}}
        self._pattern_cache: Dict[str, List[Tuple[re.Pattern[str], str, List[str]]]] = {"zh": [], "en": []}
        self._load_direct_map()
        self.load(lang)

    def load(self, lang: str):
        self.lang = lang
        path = os.path.join(self.base_dir, f"strings.{lang}.json")
        try:
            self._dicts[lang] = _load_json(path)
        except FileNotFoundError:
            self._dicts[lang] = {}
        self._rebuild_direct_maps()

    def t(self, key: str, fallback: str | None = None) -> str:
        return self._dicts.get(self.lang, {}).get(key, fallback if fallback is not None else key)

    def translate_text(self, text: str) -> str:
        return self._translate_text_for_lang(text, self.lang)

    def translate_text_to(self, text: str, lang: str) -> str:
        return self._translate_text_for_lang(text, lang)

    def _translate_text_for_lang(self, text: str, lang: str) -> str:
        if not text:
            return text
        lang_map = self._direct_maps.get(lang)
        if lang_map and text in lang_map:
            return lang_map[text]
        for pattern, target_template, field_names in self._pattern_cache.get(lang, []):
            match = pattern.match(text)
            if not match:
                continue
            values = {}
            for idx, field in enumerate(field_names):
                slot = f"__slot{idx}__"
                values[field] = match.group(slot)
            try:
                return _render_template(target_template, values)
            except Exception:
                return target_template
        return text

    # ---------- Internal ----------
    def _load_direct_map(self):
        path = os.path.join(self.base_dir, "direct.map.json")
        if os.path.exists(path):
            try:
                self._direct_raw = _load_json(path)
            except Exception:
                self._direct_raw = {}
        else:
            self._direct_raw = {}
        self._rebuild_direct_maps()

    def _rebuild_direct_maps(self):
        en_map: Dict[str, str] = {}
        zh_map: Dict[str, str] = {}
        en_patterns: List[Tuple[re.Pattern[str], str, List[str]]] = []
        zh_patterns: List[Tuple[re.Pattern[str], str, List[str]]] = []
        for zh_text, en_text in self._direct_raw.items():
            if not isinstance(zh_text, str) or not zh_text:
                continue
            if not isinstance(en_text, str) or not en_text:
                continue
            en_map[zh_text] = en_text
            zh_map[en_text] = zh_text
            if "{" in zh_text and "}" in zh_text:
                try:
                    pat, fields = _compile_pattern(zh_text)
                    en_patterns.append((pat, en_text, fields))
                except Exception:
                    pass
            if "{" in en_text and "}" in en_text:
                try:
                    pat, fields = _compile_pattern(en_text)
                    zh_patterns.append((pat, zh_text, fields))
                except Exception:
                    pass
        self._direct_maps["en"] = en_map
        self._direct_maps["zh"] = zh_map
        self._pattern_cache["en"] = en_patterns
        self._pattern_cache["zh"] = zh_patterns


# singleton
i18n = I18N()


def tr(zh: str, en: str) -> str:
    """简易双语选择，避免英文界面残留中文。"""
    return en if getattr(i18n, "lang", "zh") == "en" else zh


def trf(zh: str, en: str, **kwargs) -> str:
    """带格式化的双语选择。"""
    return tr(zh, en).format(**kwargs)

===== END FILE: app/i18n.py =====

===== FILE: app/main.py =====
# app/main.py
from __future__ import annotations
import sys
from pathlib import Path

try:
    from PySide6.QtWidgets import QApplication
    from PySide6.QtGui import QPalette, QColor, QFont, QFontDatabase
    from PySide6.QtCore import Qt, QTimer
except ModuleNotFoundError as exc:
    if exc.name == "PySide6":
        raise ModuleNotFoundError(
            "PySide6 is missing. Activate your project environment and install dependencies via \n"
            "  python -m pip install -r requirements.txt"
        ) from exc
    raise
import argparse

# 语言与扩展（容错导入）
try:
    from app.i18n import i18n
except Exception:  # 兜底占位，避免启动失败
    class _I:
        def load(self, *_args, **_kwargs):
            pass

    i18n = _I()

try:
    from app.extensions.boot import install_extensions
except Exception:
    install_extensions = None

from app.gui.main_window import MainWindow
from app.core.logging.logger import setup_logging

APP_NAME = "LiFud-DALI上位机"


def apply_light_theme(app: QApplication) -> None:
    """白底黑字的浅色主题"""
    # 1) 清空可能残留的 qdarkstyle/qdarktheme/QSS 等样式
    app.setStyleSheet("")
    # 2) 使用 Qt 的 Fusion 样式并手动设置浅色调色板
    app.setStyle("Fusion")
    pal = QPalette()
    pal.setColor(QPalette.Window, QColor(255, 255, 255))
    pal.setColor(QPalette.WindowText, Qt.black)
    pal.setColor(QPalette.Base, QColor(255, 255, 255))
    pal.setColor(QPalette.AlternateBase, QColor(245, 245, 245))
    pal.setColor(QPalette.Text, Qt.black)
    pal.setColor(QPalette.Button, QColor(240, 240, 240))
    pal.setColor(QPalette.ButtonText, Qt.black)
    pal.setColor(QPalette.ToolTipBase, QColor(255, 255, 220))
    pal.setColor(QPalette.ToolTipText, Qt.black)
    pal.setColor(QPalette.Highlight, QColor(0, 120, 215))
    pal.setColor(QPalette.HighlightedText, Qt.white)
    app.setPalette(pal)


def apply_chinese_font(app: QApplication) -> None:
    """在系统已安装中文字体的前提下，挑一个可用的全局中文字体"""
    preferred = [
        "Noto Sans CJK SC",
        "Source Han Sans SC",
        "WenQuanYi Micro Hei",
        "WenQuanYi Zen Hei",
        "Microsoft YaHei",
        "SimHei",
    ]
    families = set(QFontDatabase.families())
    for name in preferred:
        if name in families:
            app.setFont(QFont(name, 10))
            break


def main() -> int:
    # 参数解析（兼容未知参数）
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument("--light", action="store_true", default=False)
    parser.add_argument("--lang", choices=("zh", "en"), default="zh")
    args, _ = parser.parse_known_args()
    # 日志
    log_dir = Path.home() / ".dali_host" / "logs"
    log_dir.mkdir(parents=True, exist_ok=True)
    logger = setup_logging(APP_NAME, log_dir)

    app = QApplication(sys.argv)
    app.setApplicationName(APP_NAME)

    # ——外观：白底黑字 + 中文——
    # 若传入 --light 则强制 Light；否则也沿用浅色主题（与现有一致）
    apply_light_theme(app)
    apply_chinese_font(app)

    # 语言（默认 zh，可通过 --lang=en 切换）
    try:
        i18n.load(args.lang)
    except Exception:
        pass

    # 主窗口
    win = MainWindow()
    try:
        # 初始标题应用 i18n（如果资源存在）
        win.setWindowTitle(getattr(i18n, "t", lambda k, fb=None: fb or k)("app.title", APP_NAME))
    except Exception:
        pass
    win.show()

    # 在窗口显示后异步安装扩展（菜单/日志窗格/扫描入口等）
    if install_extensions is not None:
        def _boot():
            try:
                install_extensions(globals())
            except Exception as _e:
                print("[boot] install failed in main():", _e)
        QTimer.singleShot(0, _boot)

    try:
        return app.exec()
    except Exception as e:
        logger.exception("Fatal error: %s", e)
        raise


if __name__ == "__main__":
    sys.exit(main())

===== END FILE: app/main.py =====

===== FILE: i18n/direct.map.json =====
{
  "(未寻址)": "(Unaddressed)",
  "ARC 亮度": "ARC brightness",
  "ARC：亮度扫描(lo→hi，步长)": "ARC: Brightness scan (lo→hi, step size)",
  "ARC：固定亮度": "ARC: Fixed brightness",
  "DALI上位机": "DALI host machine",
  "DALI上位机（Python + Qt）\\n当前阶段：最小可用闭环（调光）": "DALI host computer (Python + Qt)\\nCurrent stage: Minimum available closed loop (dimming)",
  "DT8 / Tc 色温控制（以 Kelvin 输入，内部换算 Mirek）": "DT8 / Tc color temperature control (input as Kelvin, internally converted to Mirek)",
  "DT8 色彩：xy 与 RGBW 两种方式 + 预设色板": "DT8 Color: xy and RGBW + preset color palette",
  "DT8 色温 Tc": "DT8 Color Temperature Tc",
  "DT8：RGBW 固定": "DT8: RGBW fixed",
  "DT8：Tc 固定K": "DT8: Tc fixed K",
  "DT8：xy 固定": "DT8: xy fixed",
  "FF 21; C1 08 ... （两字节帧，分号/换行隔开）": "FF 21; C1 08 ... (two byte frames, semicolon/line break separated)",
  "JSON 顶层需为列表": "JSON top-level must be a list",
  "JSON格式应为列表": "JSON format should be a list",
  "dt8_presets: {len(st.dt8_presets)} 条": "dt8_presets: {len(st.dt8_presets)} bar",
  "groups: {len(st.groups)} 条": "groups: {len(st.groups)} bar",
  "panel_gateway_scan 未找到": "panel_gateway_scan not found",
  "scenes: {len(st.scenes)} 条": "scenes: {len(st.scenes)} bar",
  "一": "One",
  "一次性": "One-time",
  "一次性：": "One-time:",
  "三": "Three",
  "上次运行": "Last run",
  "下次运行": "Run next time",
  "不支持的命令类型": "Unsupported command types",
  "两字节帧（多帧用分号或换行分隔）：": "Two-byte frames (separate by semicolon or newline):",
  "中文": "Chinese",
  "中间(128)": "Middle (128)",
  "二": "Two",
  "二分搜索法": "Bipartite search method",
  "五": "Five",
  "亮度（ARC 0–254）": "Brightness (ARC 0–254)",
  "亮度：": "brightness:",
  "仅未寻址": "Not addressed only",
  "从组移除": "Remove from group",
  "任务名称：": "Task name:",
  "任务：": "Task:",
  "保存": "Save",
  "保存为场景（写入亮度）": "Save as scene (write brightness)",
  "保存亮度(0–254)：": "Save brightness (0–254):",
  "停止": "stop",
  "六": "Six",
  "关于": "about",
  "写入场景后回放验证": "Playback verification after writing",
  "删除": "Delete",
  "删除所选": "Delete the selected",
  "删除选中": "Delete selected",
  "刷新列表": "Refresh the list",
  "加入组": "Join the group",
  "加载失败：{e}": "Loading failed: {e}",
  "动作": "action",
  "历史记录": "History",
  "压力任务": "Stressed tasks",
  "压力测试": "Stress Test",
  "压力测试完成": "Stress test completed",
  "压力测试开始": "Stress test begins",
  "原始字节流：": "Raw byte stream:",
  "原始帧序列": "Original frame sequence",
  "原始帧解析失败：{e}": "Original frame parsing failed: {e}",
  "原始帧：": "Original frame:",
  "参数": "parameter",
  "参数：": "Parameter:",
  "发送": "Send",
  "发送ARC失败": "Failed to send ARC",
  "发送{label}": "Send {label}",
  "发送全部": "Send all",
  "发送失败": "Send failed",
  "发送失败：{e}": "Send failed: {e}",
  "发送帧/序列": "Send frames/sequences",
  "发送并接收": "Send and receive",
  "变量读写": "Variable R/W",
  "名称": "name",
  "启用": "Enable",
  "启用/禁用": "Enable/disable",
  "周{WEEK_LABELS[i]}": "Week{WEEK_LABELS[i]}",
  "命令字节 (0–255)：": "Command bytes (0–255):",
  "命令查询（is_command=1）": "Command query (is_command=1)",
  "命令：": "Command:",
  "响应": "response",
  "四": "Four",
  "回放场景": "Playback scene",
  "图_{kind}_{QDateTime.currentDateTime().toString('yyyyMMdd_HHmmss')}.png": "Figure _{kind}_{QDateTime.currentDateTime().toString('yyyyMMdd_HHmmss')}.png",
  "图类型：": "Figure type:",
  "图表": "chart",
  "在线": "Online",
  "地址分配策略": "Address assignment policy",
  "地址选择": "Address selection",
  "场景(0–15)：": "Scene (0–15):",
  "场景回放": "Scene playback",
  "场景操作": "Scene operation",
  "场景管理": "Scenario Management",
  "场景管理：回放 / 保存（写入亮度）/ 移除。": "Scene Management: Playback/Save (Write Brightness)/Remove.",
  "场景：": "Scene:",
  "均值(ms)": "Mean (ms)",
  "失败：{e}": "Failed: {e}",
  "定时任务": "Scheduled Tasks",
  "实时统计": "Real-time statistics",
  "导入 DT8 预设（写入用户预设文件）": "Import DT8 presets (write to user preset files)",
  "导入/应用完成": "Import/application completion",
  "导入JSON": "Import JSON",
  "导入JSON为历史": "Import JSON as history",
  "导入任务JSON": "Import task JSON",
  "导入失败：{e}": "Import failed: {e}",
  "导入并应用": "Import and apply",
  "导出": "Export",
  "导出CSV": "Export CSV",
  "导出JSON": "Export JSON",
  "导出任务JSON": "Export task JSON",
  "导出历史为JSON": "Export history as JSON",
  "导出图像": "Export Image",
  "导出图像 PNG": "Export Image PNG",
  "导出失败：{e}": "Export failed: {e}",
  "导出当前预设": "Export current preset",
  "导出摘要 CSV": "Export summary CSV",
  "导出摘要 JSON": "Export summary JSON",
  "导出日志": "Export Logs",
  "导出空模板": "Export empty template",
  "工具": "Tools",
  "已从组{g}移除": "Removed from group {g}",
  "已保存 场景{scene} ← 亮度{level}": "Saved Scene{scene} ← Brightness{level}",
  "已保存修改": "Saved and modified",
  "已创建任务": "Tasks created",
  "已删除": "Deleted",
  "已加入组{g}": "Joined group{g}",
  "已加载 JSON": "Loaded JSON",
  "已发送 ARC={int(val)}": "Sent ARC={int(val)}",
  "已发送 {len(pairs)} 帧": "Sent {len(pairs)} Frame",
  "已发送全部通道": "All channels have been sent",
  "已发送并收到响应": "Command sent and response received",
  "已发送：{fmt_pair(a,d)}": "Sent: {fmt_pair(a,d)}",
  "已回放场景{scene}": "Replayed scene{scene}",
  "已导入": "Imported",
  "已导出": "Exported",
  "已导出当前预设": "The current preset has been exported",
  "已导出空模板": "Empty template exported",
  "已导出：{path}": "Exported: {path}",
  "已应用预设：{p.get('name')}": "Presets applied: {p.get('name')}",
  "已应用预设：{p.get('name')} (xy)": "Preset applied: {p.get('name')} (xy)",
  "已应用预设：{p.get('name')}（{out['kelvin']}K）": "Presets applied: {p.get('name')}({out['kelvin']}K)",
  "已断开": "Disconnected",
  "已有任务在运行": "There are tasks running",
  "已添加：{path.name}": "Added: {path.name}",
  "已移除 场景{scene}": "Removed Scenario{scene}",
  "已设置 Tc={out['kelvin']}K（{out['mirek']} Mirek）": "Set Tc={out['kelvin']}K ({out['mirek']} Mirek)",
  "已设置 xy=({out['x']:.4f},{out['y']:.4f}) → ({out['x_u16']},{out['y_u16']})": "xy=({out['x']:.4f},{out['y']:.4f}) → ({out['x_u16']},{out['y_u16']})",
  "已设置 {ch.upper()}={out['level']}": "Set {ch.upper()}={out['level']}",
  "已连接": "Connected",
  "已重放": "Replayed",
  "帮助": "Help",
  "平滑窗口（仅时间序列）：": "Smooth window (time series only):",
  "广播": "broadcast",
  "序号": "Serial number",
  "应用 场景亮度表": "Apply scene brightness table",
  "应用 组成员关系": "Apply group memberships",
  "应用组时清空未列出组": "Clear unlisted groups when applying",
  "开始": "start",
  "开灯至50%": "Turn on the light to 50%",
  "快捷命令": "Quick Command",
  "总时长(ms)": "Total duration (ms)",
  "总次数：": "Total count:",
  "执行：二分搜索法": "Execution: binary search method",
  "执行：随机冲突解析": "Execution: Random conflict resolution",
  "执行：预分配映射": "Execute: Preallocate mapping",
  "扫描后自动搜灯": "Automatically search light after scanning",
  "扫描网关": "Scan the gateway",
  "扫描网关...": "Scan Gateways...",
  "指令发送": "Instruction sending",
  "接收超时（可留0）：": "Receive timeout (leave 0 to skip):",
  "接收超时：": "Receive timeout:",
  "数据": "data",
  "数据分析": "Data Analysis",
  "数据源（CSV：index,duration_ms）": "Data source (CSV: index,duration_ms)",
  "断开": "Disconnect",
  "新建": "New",
  "新建灯": "New light",
  "新建组": "Create a new group",
  "无响应（超时）": "No response (timeout)",
  "无图可导出": "No picture to export",
  "无数据": "No data",
  "无数据可导出": "No data to export",
  "日": "Sun",
  "日志窗格": "Log Pane",
  "时序/时间表": "Timing/Schedule",
  "时延 (ms)": "Delay (ms)",
  "时间": "time",
  "时间序列": "Time series",
  "时间（用于每天/每周）：": "Time (for daily/weekly):",
  "最亮(254)": "Brightest (254)",
  "最大(ms)": "Maximum (ms)",
  "最小(ms)": "Minimum (ms)",
  "最暗(0)": "Darkest (0)",
  "最近一次导入解析信息：": "Last import parse info:",
  "未命名任务": "Unnamed tasks",
  "未知预设类型": "Unknown preset type",
  "未连接": "Not connected",
  "标准差(ms)": "Standard deviation (ms)",
  "样本数": "Number of samples",
  "模拟执行": "Simulation execution",
  "次数": "frequency",
  "正在停止…": "Stopping...",
  "每周": "weekly",
  "每天": "every day",
  "没有可导出的结果": "No exportable results",
  "浏览 CSV…": "View CSV...",
  "浏览…": "Browse...",
  "添加到对比": "Add to comparison",
  "添加时序": "Add timing",
  "清空": "Clear",
  "清空对比": "Clear the comparison",
  "状态": "Status",
  "状态：{st}": "Status: {st}",
  "用 QSpinBox 包装浮点显示的保底方案（兼容性更好）；显示*10000的整数，读写时缩放。": "Use QSpinBox to package the guaranteed solution for floating point display (more compatibility); display *10000 integers, zoom during read and write.",
  "目标": "Target",
  "目标选择（建议为短地址或广播）": "Target selection (recommended for short address or broadcast)",
  "直方图": "Histogram",
  "直方图分箱数：": "Histogram binning:",
  "短地址": "Short address",
  "短址": "Short address",
  "示例：\\nFF 21\\nC1 08\\n或：FF 21; C1 08": "Example: \\nFF 21\\nC1 08\\nOr: FF 21; C1 08",
  "移除场景": "Remove scene",
  "立即执行": "Execute now",
  "箱线图": "Box chart",
  "类型：": "type:",
  "累积分布": "Cumulative distribution",
  "累计概率": "Cumulative probability",
  "组1": "Group 1",
  "组号(0–15)：": "Group number (0–15):",
  "组地址": "Group address",
  "组址": "Group address",
  "组操作": "Group operation",
  "组操作失败": "Group operation failed",
  "组管理": "Group Management",
  "组管理：加入/移除 group(0..15)。": "Group Management: Join/remove group(0..15).",
  "统计指标": "Statistical indicators",
  "编辑任务": "Edit Tasks",
  "自定义帧": "Custom frames",
  "色彩（DT8）": "Color (DT8)",
  "色温（DT8 Tc）": "Color temperature (DT8 Tc)",
  "色温（Kelvin）→ Mirek": "Color Temperature (Kelvin) → Mirek",
  "视图": "View",
  "解析失败": "Analysis failed",
  "解析失败：{e}": "Analysis failed: {e}",
  "设置 xy": "Set xy",
  "设置色温": "Set color temperature",
  "语言": "Language",
  "请先加载 JSON": "Please load JSON first",
  "请先连接网关或使用Mock": "Please connect to the gateway or use Mock",
  "请先选择一条 CSV": "Please select a CSV first",
  "调光": "Dimming",
  "调度": "Scheduling",
  "超时(s)": "Timeout(s)",
  "近似吞吐(次/秒)": "Approximate throughput (times/second)",
  "连接": "Connect",
  "连接失败：{e}": "Connection failed: {e}",
  "选择 CSV": "Select CSV",
  "选择 JSON": "Select JSON",
  "选择一个 JSON 文件…": "Select a JSON file...",
  "配置": "Configuration",
  "配置导入导出": "Config Import/Export",
  "重放": "Replay",
  "间隔": "interval",
  "间隔：": "Interval:",
  "随机冲突解析": "Random conflict analysis",
  "预分配映射": "Preallocated mapping",
  "预览（addr data）：": "Preview (addr data):",
  "预设{i+1}": "Preset{i+1}",
  "预设失败：{e}": "Preset failed: {e}",
  "预设色板": "Preset color palette",
  "频数": "Frequency",
  "默认目录：": "Default directory:",
  "（在 配置/dali.yaml 的 presets: 添加你的色板，或导入 JSON）": "(In Configure /dali.yaml presets: add your swatches, or import JSON)",
  "缺失": "Missing",
  "状态：": "Status: ",
  "图_{kind}_{timestamp}.png": "plot_{kind}_{timestamp}.png",
  "加载失败：{error}": "Load failed: {error}",
  "DALI上位机（Python + Qt）\n当前阶段：最小可用闭环（调光)": "LiFud DALI Host (Python + Qt)\nCurrent phase: Minimum viable dimming",
  "数据分析页：统计 bench CSV 并可视化。": "Analysis page: visualize bench CSV statistics.",
  "DALI上位机（Python + Qt）\\\\n当前阶段：最小可用闭环（调光)": "LiFud DALI Host (Python + Qt)\\nCurrent phase: Minimum viable dimming",
  "HEX：": "HEX:",
  "DEC：": "DEC:",
  "Preset color palette": "Preset color palette",
  "红": "Red",
  "绿": "Green",
  "蓝": "Blue",
  "暖白(2700K)": "Warm white (2700K)",
  "中性白(4000K)": "Neutral white (4000K)",
  "冷白(6500K)": "Cool white (6500K)",
  "演示红": "Demo red",
  "Week一": "Week Mon",
  "Week二": "Week Tue",
  "Week三": "Week Wed",
  "Week四": "Week Thu",
  "Week五": "Week Fri",
  "Week六": "Week Sat",
  "Week日": "Week Sun",
  "任务执行：{task.name}": "Task execution: {task.name}",
  "任务执行失败：{task.name} -> {e!r}": "Task execution failed: {task.name} -> {e!r}",
  "任务跳过（未连接）：{task.name}": "Task skipped (not connected): {task.name}",
  "导出 JSON": "Export JSON",
  "导入 JSON": "Import JSON",
  "发送{ch.upper()}": "Send {ch.upper()}",
  "发送失败：{error}": "Send failed: {error}",
  "失败：{error}": "Failed: {error}",
  "已从组{group}移除": "Removed from group {group}",
  "已加入组{group}": "Joined Group {group}",
  "已发送 ARC={value}": "Sent ARC={value}",
  "已应用预设：{name}": "Preset applied: {name}",
  "已应用预设：{name} (xy)": "Preset applied: {name} (xy)",
  "已应用预设：{name}（{kelvin}K）": "Preset applied: {name}({kelvin}K)",
  "已添加：{filename}": "Added: {filename}",
  "已设置 Tc={kelvin}K（{mirek} Mirek）": "Set Tc={kelvin}K({mirek} Mirek)",
  "已设置 xy=({x:.4f},{y:.4f}) → ({ux},{uy})": "xy=({x:.4f},{y:.4f}) → ({ux},{uy})",
  "已设置 {channel}={level}": "{channel}={level} has been set",
  "状态：{status}": "Status: {status}",
  "连接失败：{error}": "Connection failed: {error}",
  "预设失败：{error}": "Preset failed: {error}",
  "   (requirements.txt 已配置清华源，速度更快)\\n": "   (requirements.txt already points to the Tsinghua mirror for faster downloads)\\n",
  "0AAA AAAS：短地址 0..63；S=0 表示ARC亮度，S=1表示命令。": "0AAA AAAS: short addresses 0..63; S=0 means ARC brightness, S=1 means command.",
  "1) 创建虚拟环境: python3 -m venv .venv\\n": "1) Create venv: python3 -m venv .venv\\n",
  "100A AAAS：组地址 0..15。": "100A AAAS: group addresses 0..15.",
  "2) 激活: source .venv/bin/activate\\n": "2) Activate: source .venv/bin/activate\\n",
  "3) 升级工具: pip install -U pip setuptools wheel\\n": "3) Upgrade tools: pip install -U pip setuptools wheel\\n",
  "4) 安装依赖: pip install -r requirements.txt\\n": "4) Install deps: pip install -r requirements.txt\\n",
  "5) 运行: python -m app.main --light --lang=zh\\n": "5) Run: python -m app.main --light --lang=zh\\n",
  "LiFud-DALI上位机": "LiFud DALI Host",
  "YAML 解析失败，使用默认配置: %s": "Failed to parse YAML, using default config: %s",
  "{name} 超出范围 [{lo},{hi}]: {v}": "{name} out of range [{lo},{hi}]: {v}",
  "上位机核心：把GUI动作翻译为传输层帧。": "Host core: translates GUI actions into transport frames.",
  "从 group(0..15) 中移除目标。": "Remove targets from group(0..15).",
  "以 K 设置色温（DT8 / Tc）。内部自动换算 Mirek 并写 DTR0/1，再启用DT8后发送 Set-Tc。": "Set color temperature in Kelvin (DT8 / Tc). Converts to Mirek, writes DTR0/1, enables DT8, then sends Set-Tc.",
  "传输抽象层：屏蔽 TCP/串口/HID 差异。": "Transport abstraction: hides TCP/serial/HID differences.",
  "前向帧：地址字节 + 操作码/亮度（8位）。": "Forward frame: address byte + opcode/brightness (8-bit).",
  "加载任务失败：{e}": "Failed to load tasks: {e}",
  "回放场景 scene(0..15)。": "Recall scene(0..15).",
  "在系统已安装中文字体的前提下，挑一个可用的全局中文字体": "Select an available global Chinese font if installed on the system",
  "字节越界: {tok!r}": "Byte out of range: {tok!r}",
  "将目标从场景 scene(0..15) 中移除。": "Remove targets from scene(0..15).",
  "带格式化的双语选择。": "Helper for bilingual formatted strings.",
  "应用.yaml": "application.yaml",
  "按 name 去重合并（user 覆盖同名项）": "Merge by name (user values override).",
  "未安装 pyyaml，使用默认配置": "pyyaml not installed, using default config",
  "未知任务：{p.task}": "Unknown job: {p.task}",
  "未知动作：{act}": "Unknown action: {act}",
  "未知地址模式": "Unknown address mode",
  "未知目标模式": "Unknown target mode",
  "未能从 CSV 解析到任何 duration_ms：{path}": "No duration_ms parsed from CSV: {path}",
  "未解析到任何帧": "No frames parsed",
  "检测到未安装 PySide6。请按以下步骤安装:\\n": "PySide6 is missing. Please install dependencies as follows:\\n",
  "每帧必须两字节，得到 {toks!r}": "Each frame must have two bytes, but got {toks!r}",
  "用于GUI联调与自动化测试的假设备。": "Mock device used for GUI integration and automation tests.",
  "白底黑字的浅色主题": "Light theme with white background and dark text",
  "短地址缺失": "Missing short address",
  "空数据": "Empty data",
  "简易双语选择，避免英文界面残留中文。": "Simple bilingual helper to avoid Chinese leftovers in English UI.",
  "组地址缺失": "Missing group address",
  "经验分布函数：返回 (xs_sorted, ys[0..1])": "Empirical distribution function: returns (xs_sorted, ys[0..1])",
  "连接.yaml": "connection.yaml",
  "连接失败: %s": "Connection failed: %s",
  "遍历常见控件，将文本替换成当前语言。": "Walk common widgets and replace text with the current language.",
  "配置中未定义主色通道 '{channel}' 的 opcode": "Opcode for primary channel '{channel}' not defined in config",
  "非法字节: {tok!r}": "Illegal byte: {tok!r}",
  "顶层必须是对象": "Top-level YAML must be an object",
  "lo/hi/step：": "lo/hi/step:",
  "Kelvin：": "Kelvin:",
  "New": "New",
  "导入失败：{error}": "Import failed: {error}",
  "解析失败：{error}": "Parse failed: {error}",
  "DT8 xy": "DT8 xy",
  "DT8 RGBW": "DT8 RGBW"
}

===== END FILE: i18n/direct.map.json =====

===== FILE: i18n/strings.en.json =====
{
  "app.title": "LiFud DALI Host",
  "menu.language": "Language",
  "menu.language.zh": "Chinese",
  "menu.language.en": "English",
  "menu.tools": "Tools",
  "menu.tools.scan_gateways": "Scan Gateways...",
  "menu.view": "View",
  "menu.view.log_pane": "Log Pane",
  "action.export_logs": "Export Logs",
  "status.connected": "Connected",
  "status.disconnected": "Disconnected",
  "status.message": "Status: {status}",
  "status.connecting": "Connecting",
  "status.connect.failed": "Connection failed: {error}",
  "status.disconnected.brief": "Disconnected",
  "dialog.about.title": "About",
  "dialog.about.body": "LiFud DALI Host (Python + Qt)\\nCurrent phase: Minimum viable dimming"
}

===== END FILE: i18n/strings.en.json =====

===== FILE: i18n/strings.zh.json =====
{
  "app.title": "莱福德 DALI 上位机",
  "menu.language": "语言",
  "menu.language.zh": "中文",
  "menu.language.en": "English",
  "menu.tools": "工具",
  "menu.tools.scan_gateways": "扫描网关...",
  "menu.view": "视图",
  "menu.view.log_pane": "日志窗格",
  "action.export_logs": "导出日志",
  "status.connected": "已连接",
  "status.disconnected": "未连接",
  "status.message": "状态：{status}",
  "status.connecting": "连接中",
  "status.connect.failed": "连接失败：{error}",
  "status.disconnected.brief": "已断开",
  "dialog.about.title": "关于",
  "dialog.about.body": "DALI上位机（Python + Qt）\\n当前阶段：最小可用闭环（调光）"
}

===== END FILE: i18n/strings.zh.json =====

===== FILE: tests/test_dt8.py =====
from app.core.controller import Controller


def make_controller():
    cfg = {
        "gateway": {"type": "mock"},
        "ops": {},
        "tc": {"kelvin_min": 1700, "kelvin_max": 8000},
    }
    ctrl = Controller(cfg)
    ctrl.connect()
    return ctrl


def test_dt8_tc_kelvin_conversion():
    ctrl = make_controller()
    result = ctrl.dt8_set_tc_kelvin("short", 4000, addr_val=1)
    assert result["kelvin"] == 4000
    assert 240 <= result["mirek"] <= 260


def test_dt8_tc_clamp():
    ctrl = make_controller()
    res_low = ctrl.dt8_set_tc_kelvin("short", 1000, addr_val=1)
    assert res_low["kelvin"] == 1700
    res_high = ctrl.dt8_set_tc_kelvin("short", 9000, addr_val=1)
    assert res_high["kelvin"] == 8000


===== END FILE: tests/test_dt8.py =====

===== FILE: tests/test_frames.py =====
from app.core.dali.frames import (
    addr_broadcast,
    addr_group,
    addr_short,
    make_forward_frame,
)


def test_addr_short_valid():
    assert addr_short(0, False) == 0
    assert addr_short(5, True) == (5 << 1) | 1


def test_addr_short_invalid():
    try:
        addr_short(64, False)
    except ValueError:
        pass
    else:  # pragma: no cover - 确保异常抛出
        raise AssertionError("expected ValueError for short=64")


def test_addr_group_encoding():
    value = addr_group(3, True)
    assert value == 0b1000_0111


def test_addr_broadcast():
    assert addr_broadcast(is_command=False) == 0xFE
    assert addr_broadcast(is_command=True, unaddressed=True) == 0xFD


def test_make_forward_frame():
    frame = make_forward_frame(0x12, 0x34)
    assert frame == b"\x12\x34"


===== END FILE: tests/test_frames.py =====

===== FILE: tests/test_schedule.py =====
from datetime import datetime, timedelta

import pytest
from PySide6.QtCore import QCoreApplication

from app.core.schedule.manager import ScheduleManager, Task


class DummyController:
    def is_connected(self) -> bool:
        return True


@pytest.fixture(scope="module")
def qt_app():
    app = QCoreApplication.instance()
    if app is None:
        app = QCoreApplication([])
    return app


def make_manager(tmp_path):
    return ScheduleManager(DummyController(), tmp_path)


def test_interval_next(qt_app, tmp_path):
    mgr = make_manager(tmp_path)
    task = Task(
        id="interval",
        name="interval",
        enabled=True,
        mode="broadcast",
        addr_val=None,
        unaddr=False,
        action="arc",
        params={"value": 128},
        schedule={"type": "interval", "every_ms": 1000},
    )
    now = datetime.now()
    next_dt = mgr._compute_next(task, after=now)
    assert next_dt >= now + timedelta(milliseconds=1000)


def test_daily_next(qt_app, tmp_path):
    mgr = make_manager(tmp_path)
    next_minute = (datetime.now().minute + 1) % 60
    task = Task(
        id="daily",
        name="daily",
        enabled=True,
        mode="broadcast",
        addr_val=None,
        unaddr=False,
        action="arc",
        params={"value": 0},
        schedule={
            "type": "daily",
            "hour": datetime.now().hour,
            "minute": next_minute,
        },
    )
    next_dt = mgr._compute_next(task, after=datetime.now())
    assert next_dt is not None
    assert next_dt.minute == next_minute


def test_weekly_next(qt_app, tmp_path):
    mgr = make_manager(tmp_path)
    weekday = (datetime.now().weekday() + 1) % 7
    task = Task(
        id="weekly",
        name="weekly",
        enabled=True,
        mode="broadcast",
        addr_val=None,
        unaddr=False,
        action="arc",
        params={"value": 254},
        schedule={
            "type": "weekly",
            "hour": 9,
            "minute": 0,
            "weekdays": [weekday],
        },
    )
    next_dt = mgr._compute_next(task, after=datetime.now())
    assert next_dt is not None
    assert next_dt.weekday() == weekday


===== END FILE: tests/test_schedule.py =====

===== FILE: tests/test_stats.py =====
from app.core.analysis.stats import compute_stats, ecdf


def test_compute_stats_basic():
    durations = [10.0, 20.0, 30.0, 40.0]
    stats = compute_stats("sample", durations)
    assert stats.count == 4
    assert stats.min_ms == 10.0
    assert stats.max_ms == 40.0
    assert stats.p50_ms == 25.0
    assert stats.p95_ms >= stats.p50_ms
    assert stats.approx_ops_per_s > 0


def test_ecdf_sorted_output():
    xs, ys = ecdf([3, 1, 2])
    assert xs == [1, 2, 3]
    assert ys == [1 / 3, 2 / 3, 1.0]


===== END FILE: tests/test_stats.py =====

===== FILE: tools/patcher.py =====
# tools/patcher.py
from __future__ import annotations
import io, os, sys, re, argparse

def ensure_boot_call(main_path: str):
    with open(main_path, "r", encoding="utf-8") as f:
        src = f.read()
    if "app.extensions.boot" in src and "install_extensions" in src:
        return False  # already present
    trailer = "\n\n# === [AUTO PATCH] Install codeX extensions ===\n" \
              "try:\n" \
              "    from app.extensions.boot import install_extensions\n" \
              "    install_extensions()\n" \
              "except Exception as _e:\n" \
              "    print('[boot] install failed:', _e)\n"
    with open(main_path, "a", encoding="utf-8") as f:
        f.write(trailer)
    return True

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--main", default="app/main.py")
    args = ap.parse_args()
    os.makedirs("tools", exist_ok=True)
    changed = ensure_boot_call(args.main)
    print("patched" if changed else "already")

if __name__ == "__main__":
    main()

===== END FILE: tools/patcher.py =====

===== FILE: 配置/commands.yaml =====
commands:
  - name: "OFF (ARC=0)"
    type: "arc"
    value: 0

  - name: "ON (ARC=254)"
    type: "arc"
    value: 254

  - name: "Recall Scene"
    type: "base_plus_param"
    base: 64        # 0x40 + scene
    param: "scene"
    min: 0
    max: 15

  - name: "Store DTR as Scene"
    type: "base_plus_param"
    base: 80        # 0x50 + scene
    param: "scene"
    min: 0
    max: 15

  - name: "Add To Group"
    type: "base_plus_param"
    base: 96        # 0x60 + group
    param: "group"
    min: 0
    max: 15

  - name: "Remove From Group"
    type: "base_plus_param"
    base: 112       # 0x70 + group
    param: "group"
    min: 0
    max: 15

===== END FILE: 配置/commands.yaml =====

===== FILE: 配置/dali.yaml =====
ops:
  # —— 这两项用于 xy（16位，写入 DTR0/1 后发命令）——
  dt8_set_x_opcode: 224   # 0xE0  Set Temporary Chromaticity X
  dt8_set_y_opcode: 225   # 0xE1  Set Temporary Chromaticity Y
  # 常见编码（十进制）：可依据设备手册调整
  recall_scene_base: 64          # 0x40 + scene
  store_dtr_as_scene_base: 80    # 0x50 + scene
  remove_from_scene_base: 144    # 0x90 + scene
  add_to_group_base: 96          # 0x60 + group
  remove_from_group_base: 112    # 0x70 + group
  write_dtr: 163                 # 0xA3
  query_status: 144              # 0x90  Query Status
  query_groups_0_7: 192          # 0xC0  Query Groups 0-7
  query_groups_8_15: 193         # 0xC1  Query Groups 8-15
  query_scene_level_base: 176    # 0xB0 + scene
 # —— RGBW 主色控制（多数设备用 E2..E5；如有 A/F 通道再扩展）——
  dt8_set_primary:
    r: 226               # 0xE2  Set Primary R
    g: 227               # 0xE3  Set Primary G
    b: 228               # 0xE4  Set Primary B
    w: 229               # 0xE5  Set Primary W
 # —— DT8 / Tc 相关（可按设备手册改数字）——
  dt8_enable_addr: 193      # 0xC1  Enable Device Type (data=8)
  dt8_set_tc_opcode: 231    # 0xE7  Set Temporary Colour Temperature Tc（地址寻址）
  write_dtr0_addr: 163      # 0xA3  写 DTR0（addr=0xA3, data=LSB）
  write_dtr1_addr: 195      # 0xC3  写 DTR1（addr=0xC3, data=MSB）

tc:
  kelvin_min: 1700
  kelvin_max: 8000

presets:
  - name: "红"       # 纯红
    mode: "rgbw"
    values: { r: 254, g: 0, b: 0, w: 0 }

  - name: "绿"       # 纯绿
    mode: "rgbw"
    values: { r: 0, g: 254, b: 0, w: 0 }

  - name: "蓝"       # 纯蓝
    mode: "rgbw"
    values: { r: 0, g: 0, b: 254, w: 0 }

  - name: "暖白(2700K)"
    mode: "tc"
    kelvin: 2700

  - name: "中性白(4000K)"
    mode: "tc"
    kelvin: 4000

  - name: "冷白(6500K)"
    mode: "tc"
    kelvin: 6500

  - name: "D65"
    mode: "xy"
    values: { x: 0.3127, y: 0.3290 }

===== END FILE: 配置/dali.yaml =====

===== FILE: 配置/应用.yaml =====
app:
  title: "DALI上位机"
  theme: "auto"    # auto | dark | light
logging:
  level: "INFO"    # DEBUG / INFO / WARNING / ERROR

===== END FILE: 配置/应用.yaml =====

===== FILE: 配置/连接.yaml =====
gateway:
  type: "mock"     # mock | tcp
  host: "192.168.1.100"
  port: 5588
  timeout_sec: 0.8

===== END FILE: 配置/连接.yaml =====

